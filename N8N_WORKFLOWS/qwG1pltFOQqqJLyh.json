{
  "updatedAt": "2026-02-10T01:55:30.615Z",
  "createdAt": "2026-02-03T20:31:14.881Z",
  "id": "qwG1pltFOQqqJLyh",
  "name": "JSON File Works",
  "description": null,
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "inputSource": "jsonExample",
        "jsonExample": "{\n  \"filePath\": \"\",\n  \"fileAction\": \"\",\n  \"keysToReturn\": [],\n  \"keysToWrite\": {},\n  \"keysToDelete\": []\n}"
      },
      "id": "26824ef1-05ef-4896-8ef9-8f4619d64af1",
      "typeVersion": 1.1,
      "name": "Start",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "position": [
        144,
        16
      ]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "leftValue": "={{ $('Start').item.json.fileAction == \"read\"}}",
                    "rightValue": "={{ $('Start').item.json.fileAction == \"read\" }}",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "id": "eb26c69e-7c8f-43a1-8c34-72e532863446"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "read"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "fffd158a-442a-4197-82e8-b940ee3c20fb",
                    "leftValue": "={{ $('Start').item.json.fileAction == \"write\"}}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "write"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "bc448d7e-0a2f-4b8c-a74a-7f155e5bb57a",
                    "leftValue": "={{ $('Start').item.json.fileAction == \"delete\"}}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "delete"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.4,
      "position": [
        608,
        0
      ],
      "id": "f1fe66c8-f346-426f-9014-8585b51d5229",
      "name": "Switch"
    },
    {
      "parameters": {
        "fileSelector": "={{ $('Start').first().json.filePath }}",
        "options": {}
      },
      "type": "n8n-nodes-base.readWriteFile",
      "typeVersion": 1,
      "position": [
        416,
        16
      ],
      "id": "9e40db06-0b4e-4195-a7f7-a49a15110b5b",
      "name": "Read JSON File",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// ============================\n// НАСТРОЙКИ\n\n// Если бинарник с JSON лежит в ДРУГОЙ ноде — укажи её имя (ТОЧНО как в n8n).\n// Если бинарник уже приходит на вход этой Code-ноды — оставь пустую строку.\nconst SOURCE_NODE = \"Read JSON File\";\n\n// Имя бинарного поля (обычно \"data\"). Пусто = возьмём первый ключ из binary.\nconst SOURCE_BIN_KEY = \"\";\n\n// Выходное имя файла, если не удалось взять из входного бинарника / item.json.fileName\nconst DEFAULT_OUT_FILE = \"updated.json\";\n\n// Дефолтный патч — обновляем ТОЛЬКО эти поля. Остальные поля входного JSON не трогаем.\nconst PATCH_BASE = $(\"Start\").first().json.keysToWrite;\n\n// Белый список ключей, которые нужно ОСТАВИТЬ на выходе (dot-path поддерживается).\n// Если пусто/нет — не фильтруем.\nconst ONLY_KEYS_FALLBACK = $(\"Start\").first().json.keysToReturn;\n\n// ✅ Чёрный список ключей, которые нужно УДАЛИТЬ (dot-path + [n]/[-1]/[idx] поддерживается).\n// Если пусто/нет — ничего не удаляем.\nconst KEYS_TO_DELETE = $(\"Start\").first().json.keysToDelete;\n\n// Возвращать ли бинарник (по умолчанию true).\nconst RETURN_BINARY_FALLBACK = false;\n\n// Возвращать ли json в output items (по умолчанию true).\n// Важно: n8n требует поле json, поэтому если returnJson=false -> json будет {}\nconst RETURN_JSON_FALLBACK = true;\n\n// Полностью перезаписать JSON на то, что подаёшь на входе.\nconst REPLACE_WHOLE_JSON_FALLBACK = false;\n\n// Дефолтный “новый JSON” для полной замены, если на входе replaceJson не передали.\nconst DEFAULT_REPLACE_JSON = {};\n\n// ============================\n// HELPERS\n\nfunction removeBom(s) {\n  return String(s).replace(/^\\uFEFF/, \"\");\n}\n\nfunction stripJsonCommentsAndTrailingCommas(s) {\n  let t = removeBom(s);\n\n  // remove // comments\n  t = t.replace(/\\/\\/.*$/gm, \"\");\n\n  // remove /* */ comments\n  t = t.replace(/\\/\\*[\\s\\S]*?\\*\\//g, \"\");\n\n  // remove trailing commas before } or ]\n  t = t.replace(/,(\\s*[}\\]])/g, \"$1\");\n\n  return t.trim();\n}\n\nfunction extractPosFromJsonError(msg) {\n  const m = String(msg).match(/position\\s+(\\d+)/i);\n  return m ? Number(m[1]) : null;\n}\n\nfunction snippetAround(text, pos, radius = 160) {\n  if (pos == null || !Number.isFinite(pos)) {\n    const head = text.slice(0, 400);\n    return `${head}\\n^ (no position info)`;\n  }\n  const start = Math.max(0, pos - radius);\n  const end = Math.min(text.length, pos + radius);\n  const head = start > 0 ? \"… \" : \"\";\n  const tail = end < text.length ? \" …\" : \"\";\n  const slice = text.slice(start, end);\n  const caret = \" \".repeat(Math.max(0, pos - start)) + \"^\";\n  return `${head}${slice}${tail}\\n${caret}`;\n}\n\nfunction parseJsonLenient(rawText, idx) {\n  try {\n    return JSON.parse(removeBom(rawText));\n  } catch (e1) {\n    const cleaned = stripJsonCommentsAndTrailingCommas(rawText);\n    try {\n      return JSON.parse(cleaned);\n    } catch (e2) {\n      const pos = extractPosFromJsonError(e2.message) ?? extractPosFromJsonError(e1.message);\n      const snip = snippetAround(cleaned, pos);\n      throw new Error(\n        `Invalid JSON in binary (item ${idx}).\\n` +\n          `Original parse error: ${e1.message}\\n` +\n          `After comment-strip parse error: ${e2.message}\\n` +\n          `--- Snippet ---\\n${snip}`\n      );\n    }\n  }\n}\n\nfunction isPlainObject(v) {\n  return v && typeof v === \"object\" && !Array.isArray(v);\n}\n\nfunction isNumericSegment(seg) {\n  return /^-?\\d+$/.test(String(seg));\n}\n\n// ============================\n// ✅ DEEP MERGE (чтобы portsStatus не затирался целиком)\n\nfunction deepMergeObjectsInPlace(dst, src) {\n  if (!isPlainObject(dst) || !isPlainObject(src)) return dst;\n  for (const [k, v] of Object.entries(src)) {\n    if (isPlainObject(v) && isPlainObject(dst[k])) {\n      deepMergeObjectsInPlace(dst[k], v);\n    } else {\n      dst[k] = v;\n    }\n  }\n  return dst;\n}\n\nfunction cloneJson(v) {\n  try {\n    return JSON.parse(JSON.stringify(v));\n  } catch (_) {\n    return v;\n  }\n}\n\n// ============================\n// ✅ MERGE keysToWrite всех item-ов по одному filePath\n\nconst MERGED_KEYS_TO_WRITE_BY_FILEPATH = (() => {\n  const m = new Map();\n  try {\n    for (let i = 0; i < items.length; i++) {\n      const fp = items[i]?.json?.filePath;\n      const key = fp != null ? String(fp) : `__idx_${i}`;\n\n      if (!m.has(key)) {\n        const base = isPlainObject(PATCH_BASE) ? cloneJson(PATCH_BASE) : {};\n        m.set(key, base);\n      }\n\n      const kw = items[i]?.json?.keysToWrite;\n      if (isPlainObject(kw)) {\n        deepMergeObjectsInPlace(m.get(key), kw);\n      }\n    }\n  } catch (_) {}\n\n  return m;\n})();\n\n// ============================\n// PATH PARSING (dot-path + [n] + [-1] + [idx] + [*] + [+n] insert)\n\nfunction parseSelector(selRaw) {\n  const s = String(selRaw).trim();\n  if (!s) return null;\n\n  if (s === \"n\" || s === \"*\") return { kind: \"all\" };\n  if (/^\\+\\d+$/.test(s)) return { kind: \"insert\", index: Number(s.slice(1)) };\n  if (/^-?\\d+$/.test(s)) return { kind: \"index\", index: Number(s) };\n\n  return null;\n}\n\nfunction parsePathPattern(path) {\n  const raw = String(path).trim();\n  if (!raw) return [];\n\n  const dotParts = raw.split(\".\").map(s => s.trim()).filter(Boolean);\n  const steps = [];\n\n  for (const part of dotParts) {\n    // numeric dot segment => array step\n    if (!part.includes(\"[\") && isNumericSegment(part)) {\n      steps.push({ key: null, sel: { kind: \"index\", index: Number(part) } });\n      continue;\n    }\n\n    if (!part.includes(\"[\")) {\n      steps.push({ key: part, sel: null });\n      continue;\n    }\n\n    const firstBracket = part.indexOf(\"[\");\n    const prop = part.slice(0, firstBracket).trim();\n\n    const bracketMatches = [...part.matchAll(/\\[([^\\]]*)\\]/g)].map(m => m[1]);\n\n    // first bracket attaches to property if prop exists, else it's array step\n    if (prop) {\n      const sel0 = parseSelector(bracketMatches[0]);\n      steps.push({ key: prop, sel: sel0 });\n    } else {\n      const sel0 = parseSelector(bracketMatches[0]);\n      if (sel0) steps.push({ key: null, sel: sel0 });\n    }\n\n    // subsequent brackets become array steps\n    for (let i = 1; i < bracketMatches.length; i++) {\n      const sel = parseSelector(bracketMatches[i]);\n      if (sel) steps.push({ key: null, sel });\n    }\n  }\n\n  return steps;\n}\n\nfunction normalizeIndex(idx, length) {\n  let i = Number(idx);\n  if (!Number.isFinite(i)) return null;\n\n  if (i < 0) i = length + i; // -1 => last\n  if (i < 0 || i >= length) return null;\n\n  return i;\n}\n\nfunction nextContainerForStep(nextStep) {\n  return nextStep && nextStep.key == null ? [] : {};\n}\n\n// ============================\n// PROJECTION (keysToReturn) + ✅ NEW \"src:dst\" mapping\n\n// Разбираем строку вида \"proxyServerIP:ip\"\nfunction splitReturnMapping(expr) {\n  const s = String(expr ?? \"\").trim();\n  if (!s) return null;\n\n  const pos = s.indexOf(\":\");\n  if (pos <= 0) return { src: s, dst: null }; // без маппинга\n\n  const src = s.slice(0, pos).trim();\n  const dst = s.slice(pos + 1).trim();\n\n  if (!src) return { src: s, dst: null };\n  if (!dst) return { src, dst: src }; // \"a:\" -> как будто \"a:a\"\n\n  return { src, dst };\n}\n\n// Получить ВСЕ значения по steps (если встретили [*] -> вернём много)\nfunction collectValuesBySteps(node, steps, pos) {\n  if (pos >= steps.length) return [node];\n\n  const step = steps[pos];\n\n  // array step on current\n  if (step.key == null) {\n    if (!Array.isArray(node) || !step.sel) return [];\n\n    if (step.sel.kind === \"all\") {\n      const out = [];\n      for (let i = 0; i < node.length; i++) {\n        out.push(...collectValuesBySteps(node[i], steps, pos + 1));\n      }\n      return out;\n    }\n\n    if (step.sel.kind === \"index\") {\n      const i = normalizeIndex(step.sel.index, node.length);\n      if (i == null) return [];\n      return collectValuesBySteps(node[i], steps, pos + 1);\n    }\n\n    return [];\n  }\n\n  // property step\n  if (node == null || typeof node !== \"object\") return [];\n  if (!Object.prototype.hasOwnProperty.call(node, step.key)) return [];\n\n  const val = node[step.key];\n\n  if (!step.sel) {\n    return collectValuesBySteps(val, steps, pos + 1);\n  }\n\n  if (!Array.isArray(val)) return [];\n\n  if (step.sel.kind === \"all\") {\n    const out = [];\n    for (let i = 0; i < val.length; i++) {\n      out.push(...collectValuesBySteps(val[i], steps, pos + 1));\n    }\n    return out;\n  }\n\n  if (step.sel.kind === \"index\") {\n    const i = normalizeIndex(step.sel.index, val.length);\n    if (i == null) return [];\n    return collectValuesBySteps(val[i], steps, pos + 1);\n  }\n\n  return [];\n}\n\n// Записать значение по dest steps (если value — массив, просто запишем массив)\nfunction setValueBySteps(root, steps, pos, value) {\n  if (pos >= steps.length) return;\n\n  const step = steps[pos];\n\n  // array step on current\n  if (step.key == null) {\n    if (!Array.isArray(root) || !step.sel) return;\n\n    if (step.sel.kind === \"all\") {\n      // пишем во все существующие элементы (если их нет — ничего не делаем)\n      for (let i = 0; i < root.length; i++) {\n        if (pos === steps.length - 1) {\n          root[i] = value;\n        } else {\n          const next = steps[pos + 1];\n          if (root[i] == null || typeof root[i] !== \"object\") {\n            root[i] = nextContainerForStep(next);\n          }\n          setValueBySteps(root[i], steps, pos + 1, value);\n        }\n      }\n      return;\n    }\n\n    if (step.sel.kind === \"index\") {\n      let idx = step.sel.index;\n      if (!Number.isFinite(idx)) return;\n\n      // поддержка -1\n      if (idx < 0) idx = root.length + idx;\n      if (idx < 0) idx = 0;\n\n      while (root.length <= idx) root.push(undefined);\n\n      if (pos === steps.length - 1) {\n        root[idx] = value;\n      } else {\n        const next = steps[pos + 1];\n        if (root[idx] == null || typeof root[idx] !== \"object\") {\n          root[idx] = nextContainerForStep(next);\n        }\n        setValueBySteps(root[idx], steps, pos + 1, value);\n      }\n      return;\n    }\n\n    return;\n  }\n\n  // property step\n  if (root == null || typeof root !== \"object\") return;\n\n  // no selector\n  if (!step.sel) {\n    if (pos === steps.length - 1) {\n      root[step.key] = value;\n      return;\n    }\n\n    const next = steps[pos + 1];\n    const wantsArray = next.key == null;\n\n    if (root[step.key] == null || typeof root[step.key] !== \"object\") {\n      root[step.key] = wantsArray ? [] : {};\n    } else {\n      if (wantsArray && !Array.isArray(root[step.key])) root[step.key] = [];\n      if (!wantsArray && Array.isArray(root[step.key])) root[step.key] = {};\n    }\n\n    setValueBySteps(root[step.key], steps, pos + 1, value);\n    return;\n  }\n\n  // selector on property => property должен быть массивом\n  if (!Array.isArray(root[step.key])) root[step.key] = [];\n  const arr = root[step.key];\n\n  if (step.sel.kind === \"all\") {\n    for (let i = 0; i < arr.length; i++) {\n      if (pos === steps.length - 1) {\n        arr[i] = value;\n      } else {\n        const next = steps[pos + 1];\n        if (arr[i] == null || typeof arr[i] !== \"object\") {\n          arr[i] = nextContainerForStep(next);\n        }\n        setValueBySteps(arr[i], steps, pos + 1, value);\n      }\n    }\n    return;\n  }\n\n  if (step.sel.kind === \"index\") {\n    let idx = step.sel.index;\n    if (!Number.isFinite(idx)) return;\n\n    if (idx < 0) idx = arr.length + idx;\n    if (idx < 0) idx = 0;\n\n    while (arr.length <= idx) arr.push(undefined);\n\n    if (pos === steps.length - 1) {\n      arr[idx] = value;\n    } else {\n      const next = steps[pos + 1];\n      if (arr[idx] == null || typeof arr[idx] !== \"object\") {\n        arr[idx] = nextContainerForStep(next);\n      }\n      setValueBySteps(arr[idx], steps, pos + 1, value);\n    }\n  }\n}\n\n// Старый проектор (без маппинга) оставляем как есть\nfunction applyProjectionPath(outNode, srcNode, steps, pos) {\n  if (pos >= steps.length) return;\n\n  const step = steps[pos];\n\n  // array step on current value\n  if (step.key == null) {\n    if (!Array.isArray(srcNode)) return;\n    if (!Array.isArray(outNode)) return;\n\n    const sel = step.sel;\n    if (!sel) return;\n\n    if (sel.kind === \"all\") {\n      for (let i = 0; i < srcNode.length; i++) {\n        const srcEl = srcNode[i];\n\n        if (pos === steps.length - 1) {\n          outNode[i] = srcEl;\n          continue;\n        }\n\n        if (outNode[i] == null || typeof outNode[i] !== \"object\") {\n          outNode[i] = nextContainerForStep(steps[pos + 1]);\n        } else {\n          if (steps[pos + 1].key == null && !Array.isArray(outNode[i])) outNode[i] = [];\n          if (steps[pos + 1].key != null && Array.isArray(outNode[i])) outNode[i] = {};\n        }\n\n        applyProjectionPath(outNode[i], srcEl, steps, pos + 1);\n      }\n      return;\n    }\n\n    if (sel.kind === \"index\") {\n      const i = normalizeIndex(sel.index, srcNode.length);\n      if (i == null) return;\n      const srcEl = srcNode[i];\n\n      if (pos === steps.length - 1) {\n        outNode.push(srcEl);\n        return;\n      }\n\n      const container = nextContainerForStep(steps[pos + 1]);\n      outNode.push(container);\n      applyProjectionPath(container, srcEl, steps, pos + 1);\n      return;\n    }\n\n    return;\n  }\n\n  // property step\n  if (srcNode == null || typeof srcNode !== \"object\") return;\n  if (!Object.prototype.hasOwnProperty.call(srcNode, step.key)) return;\n\n  const srcVal = srcNode[step.key];\n\n  // no selector\n  if (!step.sel) {\n    if (pos === steps.length - 1) {\n      outNode[step.key] = srcVal;\n      return;\n    }\n\n    const next = steps[pos + 1];\n    const wanted = nextContainerForStep(next);\n\n    if (outNode[step.key] == null || typeof outNode[step.key] !== \"object\") {\n      outNode[step.key] = wanted;\n    } else {\n      if (next.key == null && !Array.isArray(outNode[step.key])) outNode[step.key] = [];\n      if (next.key != null && Array.isArray(outNode[step.key])) outNode[step.key] = {};\n    }\n\n    applyProjectionPath(outNode[step.key], srcVal, steps, pos + 1);\n    return;\n  }\n\n  // selector on property\n  if (!Array.isArray(srcVal)) return;\n\n  if (step.sel.kind === \"all\") {\n    if (!Array.isArray(outNode[step.key])) outNode[step.key] = [];\n    const outArr = outNode[step.key];\n\n    for (let i = 0; i < srcVal.length; i++) {\n      const srcEl = srcVal[i];\n\n      if (pos === steps.length - 1) {\n        outArr[i] = srcEl;\n        continue;\n      }\n\n      const next = steps[pos + 1];\n      const wanted = nextContainerForStep(next);\n\n      if (outArr[i] == null || typeof outArr[i] !== \"object\") {\n        outArr[i] = wanted;\n      } else {\n        if (next.key == null && !Array.isArray(outArr[i])) outArr[i] = [];\n        if (next.key != null && Array.isArray(outArr[i])) outArr[i] = {};\n      }\n\n      applyProjectionPath(outArr[i], srcEl, steps, pos + 1);\n    }\n\n    return;\n  }\n\n  if (step.sel.kind === \"index\") {\n    const i = normalizeIndex(step.sel.index, srcVal.length);\n    if (i == null) return;\n\n    if (!Array.isArray(outNode[step.key])) outNode[step.key] = [];\n    const outArr = outNode[step.key];\n    const srcEl = srcVal[i];\n\n    if (pos === steps.length - 1) {\n      outArr.push(srcEl);\n      return;\n    }\n\n    const container = nextContainerForStep(steps[pos + 1]);\n    outArr.push(container);\n    applyProjectionPath(container, srcEl, steps, pos + 1);\n    return;\n  }\n}\n\nfunction projectObjectByKeys(src, onlyKeys) {\n  if (!onlyKeys || !onlyKeys.length) return src;\n\n  if (Array.isArray(src)) {\n    return src.map(el => projectObjectByKeys(el, onlyKeys));\n  }\n\n  if (!isPlainObject(src)) return src;\n\n  const out = {};\n  for (const kRaw of onlyKeys) {\n    const m = splitReturnMapping(kRaw);\n    if (!m) continue;\n\n    const srcPath = String(m.src).trim();\n    if (!srcPath) continue;\n\n    // ✅ обычный режим (как было)\n    if (!m.dst) {\n      const steps = parsePathPattern(srcPath);\n      if (!steps.length) continue;\n      applyProjectionPath(out, src, steps, 0);\n      continue;\n    }\n\n    // ✅ режим \"src:dst\"\n    const dstPath = String(m.dst).trim();\n    if (!dstPath) continue;\n\n    const srcSteps = parsePathPattern(srcPath);\n    const dstSteps = parsePathPattern(dstPath);\n    if (!srcSteps.length || !dstSteps.length) continue;\n\n    const values = collectValuesBySteps(src, srcSteps, 0);\n    if (!values.length) continue;\n\n    const valToSet = values.length === 1 ? values[0] : values;\n    setValueBySteps(out, dstSteps, 0, valToSet);\n  }\n  return out;\n}\n\n// ============================\n// DELETE (keysToDelete) — dot-path + [] + [n]/[-1]/[idx]\n\nfunction deleteBySteps(root, steps, pos) {\n  if (pos >= steps.length) return;\n\n  const step = steps[pos];\n\n  // array step on current\n  if (step.key == null) {\n    if (!Array.isArray(root) || !step.sel) return;\n\n    if (step.sel.kind === \"all\") {\n      for (let i = 0; i < root.length; i++) {\n        if (pos === steps.length - 1) {\n          root.splice(i, 1);\n          i--;\n        } else {\n          deleteBySteps(root[i], steps, pos + 1);\n        }\n      }\n      return;\n    }\n\n    if (step.sel.kind === \"index\") {\n      let idx = step.sel.index;\n      if (!Number.isFinite(idx)) return;\n      if (idx < 0) idx = root.length + idx;\n      if (idx < 0 || idx >= root.length) return;\n\n      if (pos === steps.length - 1) {\n        root.splice(idx, 1);\n      } else {\n        deleteBySteps(root[idx], steps, pos + 1);\n      }\n      return;\n    }\n\n    return;\n  }\n\n  // property step\n  if (root == null || typeof root !== \"object\") return;\n  if (!Object.prototype.hasOwnProperty.call(root, step.key)) return;\n\n  // no selector\n  if (!step.sel) {\n    if (pos === steps.length - 1) {\n      delete root[step.key];\n      return;\n    }\n    deleteBySteps(root[step.key], steps, pos + 1);\n    return;\n  }\n\n  // selector on property\n  const val = root[step.key];\n  if (!Array.isArray(val)) return;\n\n  if (step.sel.kind === \"all\") {\n    if (pos === steps.length - 1) {\n      delete root[step.key];\n      return;\n    }\n    for (let i = 0; i < val.length; i++) {\n      deleteBySteps(val[i], steps, pos + 1);\n    }\n    return;\n  }\n\n  if (step.sel.kind === \"index\") {\n    let idx = step.sel.index;\n    if (!Number.isFinite(idx)) return;\n    if (idx < 0) idx = val.length + idx;\n    if (idx < 0 || idx >= val.length) return;\n\n    if (pos === steps.length - 1) {\n      val.splice(idx, 1);\n      return;\n    }\n    deleteBySteps(val[idx], steps, pos + 1);\n    return;\n  }\n}\n\nfunction deleteKeysByPaths(root, keysToDelete) {\n  if (!keysToDelete || !Array.isArray(keysToDelete) || !keysToDelete.length) return root;\n\n  // если root — массив, применяем ко всем элементам\n  if (Array.isArray(root)) {\n    for (let i = 0; i < root.length; i++) {\n      deleteKeysByPaths(root[i], keysToDelete);\n    }\n    return root;\n  }\n\n  if (!isPlainObject(root)) return root;\n\n  for (const kRaw of keysToDelete) {\n    const k = String(kRaw).trim();\n    if (!k) continue;\n    const steps = parsePathPattern(k);\n    if (!steps.length) continue;\n    deleteBySteps(root, steps, 0);\n  }\n\n  return root;\n}\n\n// ============================\n// PATCH APPLY (dot-path + [] + [n] + [+n])\n\nfunction ensureArrayContainer(v) {\n  if (Array.isArray(v)) return v;\n  return [];\n}\n\nfunction applyPatchPath(target, steps, pos, value) {\n  if (pos >= steps.length) return;\n\n  const step = steps[pos];\n\n  // array step on current\n  if (step.key == null) {\n    if (!Array.isArray(target)) return;\n    const sel = step.sel;\n    if (!sel) return;\n\n    // ✅ insert with shift: [ +n ]\n    if (sel.kind === \"insert\") {\n      let ins = Number(sel.index);\n      if (!Number.isFinite(ins)) return;\n      if (ins < 0) ins = 0;\n      if (ins > target.length) ins = target.length;\n\n      if (pos === steps.length - 1) {\n        target.splice(ins, 0, value);\n        return;\n      }\n\n      const next = steps[pos + 1];\n      const container = nextContainerForStep(next);\n      target.splice(ins, 0, container);\n      applyPatchPath(container, steps, pos + 1, value);\n      return;\n    }\n\n    if (sel.kind === \"all\") {\n      for (let i = 0; i < target.length; i++) {\n        if (pos === steps.length - 1) {\n          target[i] = value;\n          continue;\n        }\n        const next = steps[pos + 1];\n        if (target[i] == null || typeof target[i] !== \"object\") {\n          target[i] = nextContainerForStep(next);\n        }\n        applyPatchPath(target[i], steps, pos + 1, value);\n      }\n      return;\n    }\n\n    if (sel.kind === \"index\") {\n      let idx = sel.index;\n      if (!Number.isFinite(idx)) return;\n\n      if (idx < 0) idx = target.length + idx;\n      if (idx < 0) idx = 0;\n\n      while (target.length <= idx) target.push(undefined);\n\n      if (pos === steps.length - 1) {\n        target[idx] = value;\n        return;\n      }\n\n      const next = steps[pos + 1];\n      if (target[idx] == null || typeof target[idx] !== \"object\") {\n        target[idx] = nextContainerForStep(next);\n      }\n      applyPatchPath(target[idx], steps, pos + 1, value);\n      return;\n    }\n\n    return;\n  }\n\n  // property step\n  if (target == null || typeof target !== \"object\") return;\n\n  if (!step.sel) {\n    if (pos === steps.length - 1) {\n      // ✅ если оба объекта — мерджим, а не перезатираем\n      if (isPlainObject(value) && isPlainObject(target[step.key])) {\n        deepMergeObjectsInPlace(target[step.key], value);\n      } else {\n        target[step.key] = value;\n      }\n      return;\n    }\n\n    const next = steps[pos + 1];\n    const wantsArray = next.key == null;\n\n    if (target[step.key] == null || typeof target[step.key] !== \"object\") {\n      target[step.key] = wantsArray ? [] : {};\n    } else {\n      if (wantsArray && !Array.isArray(target[step.key])) target[step.key] = [];\n      if (!wantsArray && Array.isArray(target[step.key])) target[step.key] = {};\n    }\n\n    applyPatchPath(target[step.key], steps, pos + 1, value);\n    return;\n  }\n\n  target[step.key] = ensureArrayContainer(target[step.key]);\n  const arr = target[step.key];\n\n  // ✅ insert with shift for property-array: prop[+n]\n  if (step.sel.kind === \"insert\") {\n    let ins = Number(step.sel.index);\n    if (!Number.isFinite(ins)) return;\n    if (ins < 0) ins = 0;\n    if (ins > arr.length) ins = arr.length;\n\n    if (pos === steps.length - 1) {\n      arr.splice(ins, 0, value);\n      return;\n    }\n\n    const next = steps[pos + 1];\n    const container = nextContainerForStep(next);\n    arr.splice(ins, 0, container);\n    applyPatchPath(container, steps, pos + 1, value);\n    return;\n  }\n\n  if (step.sel.kind === \"all\") {\n    for (let i = 0; i < arr.length; i++) {\n      if (pos === steps.length - 1) {\n        arr[i] = value;\n        continue;\n      }\n      const next = steps[pos + 1];\n      if (arr[i] == null || typeof arr[i] !== \"object\") {\n        arr[i] = nextContainerForStep(next);\n      }\n      applyPatchPath(arr[i], steps, pos + 1, value);\n    }\n    return;\n  }\n\n  if (step.sel.kind === \"index\") {\n    let idx = step.sel.index;\n    if (!Number.isFinite(idx)) return;\n\n    if (idx < 0) idx = arr.length + idx;\n    if (idx < 0) idx = 0;\n\n    while (arr.length <= idx) arr.push(undefined);\n\n    if (pos === steps.length - 1) {\n      arr[idx] = value;\n      return;\n    }\n\n    const next = steps[pos + 1];\n    if (arr[idx] == null || typeof arr[idx] !== \"object\") {\n      arr[idx] = nextContainerForStep(next);\n    }\n    applyPatchPath(arr[idx], steps, pos + 1, value);\n    return;\n  }\n}\n\nfunction applyPatchToAny(root, patch) {\n  if (!patch || typeof patch !== \"object\") return root;\n\n  if (Array.isArray(root)) {\n    for (let i = 0; i < root.length; i++) {\n      if (root[i] && typeof root[i] === \"object\") {\n        applyPatchToAny(root[i], patch);\n      }\n    }\n    return root;\n  }\n\n  if (!isPlainObject(root)) return root;\n\n  for (const [kRaw, v] of Object.entries(patch)) {\n    if (v === undefined) continue;\n    const k = String(kRaw).trim();\n    if (!k) continue;\n\n    const steps = parsePathPattern(k);\n    if (!steps.length) continue;\n\n    applyPatchPath(root, steps, 0, v);\n  }\n\n  return root;\n}\n\n// ============================\n// OTHER HELPERS\n\nfunction buildPatchForItem(item, idx) {\n  const fp = item.json?.filePath;\n  const key = fp != null ? String(fp) : `__idx_${idx}`;\n\n  const merged = MERGED_KEYS_TO_WRITE_BY_FILEPATH.get(key);\n  const patch = isPlainObject(merged)\n    ? cloneJson(merged)\n    : (isPlainObject(PATCH_BASE) ? cloneJson(PATCH_BASE) : {});\n\n  const extraPatch = item.json?.patch ?? $input.first()?.json?.patch;\n  if (isPlainObject(extraPatch)) {\n    deepMergeObjectsInPlace(patch, extraPatch);\n  }\n\n  return patch;\n}\n\nfunction resolveOnlyKeys(item) {\n  const keys =\n    item.json?.onlyKeys ??\n    $input.first()?.json?.onlyKeys ??\n    ONLY_KEYS_FALLBACK;\n\n  if (!Array.isArray(keys)) return null;\n  const cleaned = keys.map(k => String(k).trim()).filter(Boolean);\n  return cleaned.length ? cleaned : null;\n}\n\nfunction resolveKeysToDelete(item) {\n  const keys =\n    item.json?.keysToDelete ??\n    $input.first()?.json?.keysToDelete ??\n    KEYS_TO_DELETE;\n\n  if (!Array.isArray(keys)) return null;\n  const cleaned = keys.map(k => String(k).trim()).filter(Boolean);\n  return cleaned.length ? cleaned : null;\n}\n\nfunction resolveReturnBinary(item) {\n  if (item.json?.returnBinary !== undefined) return Boolean(item.json.returnBinary);\n  const g = $input.first()?.json?.returnBinary;\n  if (g !== undefined) return Boolean(g);\n  return Boolean(RETURN_BINARY_FALLBACK);\n}\n\nfunction resolveReturnJson(item) {\n  if (item.json?.returnJson !== undefined) return Boolean(item.json.returnJson);\n  const g = $input.first()?.json?.returnJson;\n  if (g !== undefined) return Boolean(g);\n  return Boolean(RETURN_JSON_FALLBACK);\n}\n\nfunction resolveReplaceWholeJson(item) {\n  if (item.json?.replaceWholeJson !== undefined) return Boolean(item.json.replaceWholeJson);\n  const g = $input.first()?.json?.replaceWholeJson;\n  if (g !== undefined) return Boolean(g);\n  return Boolean(REPLACE_WHOLE_JSON_FALLBACK);\n}\n\nfunction getReplaceJson(item) {\n  const v = item.json?.replaceJson ?? $input.first()?.json?.replaceJson;\n  return v !== undefined ? v : DEFAULT_REPLACE_JSON;\n}\n\nfunction getSourceItemForIndexSafe(idx) {\n  try {\n    if (!SOURCE_NODE) return items[idx] ?? null;\n\n    try {\n      const m = $(SOURCE_NODE).itemMatching(idx);\n      if (m) return m;\n    } catch (_) {}\n\n    try {\n      const all = $(SOURCE_NODE).all();\n      if (all?.[idx]) return all[idx];\n    } catch (_) {}\n\n    // ✅ fallback если source-node отдал 1 item, а текущих items много\n    try {\n      return $(SOURCE_NODE).first() ?? null;\n    } catch (_) {}\n\n    return null;\n  } catch (_) {\n    return null;\n  }\n}\n\nfunction pickBinKeySafe(srcItem) {\n  try {\n    if (SOURCE_BIN_KEY) return SOURCE_BIN_KEY;\n    const keys = Object.keys(srcItem?.binary || {});\n    return keys[0] || \"\";\n  } catch (_) {\n    return \"\";\n  }\n}\n\nfunction hasBinaryPayload(srcItem, binKey) {\n  try {\n    if (!srcItem?.binary?.[binKey]) return false;\n    const b = srcItem.binary[binKey];\n    if (typeof b.data === \"string\" && b.data.length > 0) return true;\n    return false;\n  } catch (_) {\n    return false;\n  }\n}\n\nfunction shouldWriteEmptyFile(jsonObj) {\n  if (!jsonObj) return true;\n  if (isPlainObject(jsonObj)) return Object.keys(jsonObj).length === 0;\n  if (Array.isArray(jsonObj)) return jsonObj.length === 0;\n  return false;\n}\n\nfunction applyReturnJsonFlag(result, shouldReturnJson) {\n  if (!shouldReturnJson) result.json = {};\n  return result;\n}\n\nfunction makeFallbackJson(item, idx) {\n  const json = {};\n  const patch = buildPatchForItem(item, idx);\n  applyPatchToAny(json, patch);\n\n  const keysToDelete = resolveKeysToDelete(item);\n  deleteKeysByPaths(json, keysToDelete);\n\n  const onlyKeys = resolveOnlyKeys(item);\n  return projectObjectByKeys(json, onlyKeys);\n}\n\n// ============================\n// MAIN\n\nreturn await Promise.all(\n  items.map(async (item, idx) => {\n    const shouldReturnBinary = resolveReturnBinary(item);\n    const shouldReturnJson = resolveReturnJson(item);\n    const shouldReplaceWholeJson = resolveReplaceWholeJson(item);\n\n    // ====== РЕЖИМ ПОЛНОЙ ЗАМЕНЫ JSON ======\n    if (shouldReplaceWholeJson) {\n      let json = getReplaceJson(item);\n      if (!isPlainObject(json) && !Array.isArray(json)) json = {};\n\n      const keysToDelete = resolveKeysToDelete(item);\n      deleteKeysByPaths(json, keysToDelete);\n\n      const onlyKeys = resolveOnlyKeys(item);\n      json = projectObjectByKeys(json, onlyKeys);\n\n      const result = { json, pairedItem: idx };\n\n      if (shouldReturnBinary) {\n        const fileName =\n          (item.json?.fileName && String(item.json.fileName).trim()) ||\n          DEFAULT_OUT_FILE;\n\n        const outText = shouldWriteEmptyFile(json) ? \"\" : (JSON.stringify(json, null, 2) + \"\\n\");\n        const outBuf = Buffer.from(outText, \"utf8\");\n\n        const binaryData = await this.helpers.prepareBinaryData(\n          outBuf,\n          fileName,\n          \"application/json\"\n        );\n\n        result.binary = { data: binaryData };\n      }\n\n      return applyReturnJsonFlag(result, shouldReturnJson);\n    }\n\n    // ====== ОБЫЧНЫЙ РЕЖИМ ======\n\n    const srcItem = getSourceItemForIndexSafe(idx);\n    const binKey = pickBinKeySafe(srcItem);\n\n    if (!srcItem || !binKey || !hasBinaryPayload(srcItem, binKey)) {\n      const json = makeFallbackJson(item, idx);\n\n      const result = { json, pairedItem: idx };\n\n      if (shouldReturnBinary) {\n        const fileName =\n          (item.json?.fileName && String(item.json.fileName).trim()) ||\n          srcItem?.binary?.[binKey]?.fileName ||\n          DEFAULT_OUT_FILE;\n\n        const outText = shouldWriteEmptyFile(json) ? \"\" : (JSON.stringify(json, null, 2) + \"\\n\");\n        const outBuf = Buffer.from(outText, \"utf8\");\n\n        const binaryData = await this.helpers.prepareBinaryData(\n          outBuf,\n          fileName,\n          \"application/json\"\n        );\n\n        result.binary = { data: binaryData };\n      }\n\n      return applyReturnJsonFlag(result, shouldReturnJson);\n    }\n\n    try {\n      if (SOURCE_NODE) {\n        item.binary = item.binary || {};\n        item.binary[binKey] = srcItem.binary[binKey];\n      }\n    } catch (_) {}\n\n    let text = \"\";\n    try {\n      const buf = await this.helpers.getBinaryDataBuffer(idx, binKey);\n      if (buf && buf.length) text = buf.toString(\"utf8\");\n    } catch (_) {}\n\n    if (!text || !String(text).trim()) {\n      const json = makeFallbackJson(item, idx);\n\n      const result = { json, pairedItem: idx };\n\n      if (shouldReturnBinary) {\n        const fileName =\n          (item.json?.fileName && String(item.json.fileName).trim()) ||\n          srcItem.binary?.[binKey]?.fileName ||\n          DEFAULT_OUT_FILE;\n\n        const outText = shouldWriteEmptyFile(json) ? \"\" : (JSON.stringify(json, null, 2) + \"\\n\");\n        const outBuf = Buffer.from(outText, \"utf8\");\n\n        const binaryData = await this.helpers.prepareBinaryData(\n          outBuf,\n          fileName,\n          \"application/json\"\n        );\n\n        result.binary = { data: binaryData };\n      }\n\n      return applyReturnJsonFlag(result, shouldReturnJson);\n    }\n\n    let json;\n    try {\n      json = parseJsonLenient(text, idx);\n      if (!isPlainObject(json) && !Array.isArray(json)) json = {};\n    } catch (_) {\n      json = {};\n    }\n\n    const patch = buildPatchForItem(item, idx);\n\n    if (isPlainObject(json) || Array.isArray(json)) {\n      applyPatchToAny(json, patch);\n    } else {\n      json = makeFallbackJson(item, idx);\n    }\n\n    const keysToDelete = resolveKeysToDelete(item);\n    deleteKeysByPaths(json, keysToDelete);\n\n    const onlyKeys = resolveOnlyKeys(item);\n    json = projectObjectByKeys(json, onlyKeys);\n\n    const result = { json, pairedItem: idx };\n\n    if (shouldReturnBinary) {\n      const fileName =\n        (item.json?.fileName && String(item.json.fileName).trim()) ||\n        srcItem.binary?.[binKey]?.fileName ||\n        DEFAULT_OUT_FILE;\n\n      const outText = shouldWriteEmptyFile(json) ? \"\" : (JSON.stringify(json, null, 2) + \"\\n\");\n      const outBuf = Buffer.from(outText, \"utf8\");\n\n      const binaryData = await this.helpers.prepareBinaryData(\n        outBuf,\n        fileName,\n        \"application/json\"\n      );\n\n      result.binary = { data: binaryData };\n    }\n\n    return applyReturnJsonFlag(result, shouldReturnJson);\n  })\n);\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        848,
        -144
      ],
      "id": "e778dbb1-3aa9-460d-9447-3311ed6fd87a",
      "name": "Return Json Keys"
    },
    {
      "parameters": {
        "jsCode": "const SOURCE_NODE = \"Read JSON File\";\nconst SOURCE_BIN_KEY = \"\";\nconst DEFAULT_OUT_FILE = \"updated.json\";\nconst PATCH_BASE = $('Start').first().json.keysToWrite;\nconst ONLY_KEYS_FALLBACK = $('Start').first().json.keysToReturn;\nconst KEYS_TO_DELETE = $('Start').first().json.keysToDelete;\nconst RETURN_BINARY_FALLBACK = true;\nconst RETURN_JSON_FALLBACK = false;\nconst REPLACE_WHOLE_JSON_FALLBACK = false;\nconst DEFAULT_REPLACE_JSON = {};\n\n// ============================\n// HELPERS\n\nfunction removeBom(s) {\n  return String(s).replace(/^\\uFEFF/, \"\");\n}\n\nfunction stripJsonCommentsAndTrailingCommas(s) {\n  let t = removeBom(s);\n\n  // remove // comments\n  t = t.replace(/\\/\\/.*$/gm, \"\");\n\n  // remove /* */ comments\n  t = t.replace(/\\/\\*[\\s\\S]*?\\*\\//g, \"\");\n\n  // remove trailing commas before } or ]\n  t = t.replace(/,(\\s*[}\\]])/g, \"$1\");\n\n  return t.trim();\n}\n\nfunction extractPosFromJsonError(msg) {\n  const m = String(msg).match(/position\\s+(\\d+)/i);\n  return m ? Number(m[1]) : null;\n}\n\nfunction snippetAround(text, pos, radius = 160) {\n  if (pos == null || !Number.isFinite(pos)) {\n    const head = text.slice(0, 400);\n    return `${head}\\n^ (no position info)`;\n  }\n  const start = Math.max(0, pos - radius);\n  const end = Math.min(text.length, pos + radius);\n  const head = start > 0 ? \"… \" : \"\";\n  const tail = end < text.length ? \" …\" : \"\";\n  const slice = text.slice(start, end);\n  const caret = \" \".repeat(Math.max(0, pos - start)) + \"^\";\n  return `${head}${slice}${tail}\\n${caret}`;\n}\n\nfunction parseJsonLenient(rawText, idx) {\n  try {\n    return JSON.parse(removeBom(rawText));\n  } catch (e1) {\n    const cleaned = stripJsonCommentsAndTrailingCommas(rawText);\n    try {\n      return JSON.parse(cleaned);\n    } catch (e2) {\n      const pos = extractPosFromJsonError(e2.message) ?? extractPosFromJsonError(e1.message);\n      const snip = snippetAround(cleaned, pos);\n      throw new Error(\n        `Invalid JSON in binary (item ${idx}).\\n` +\n          `Original parse error: ${e1.message}\\n` +\n          `After comment-strip parse error: ${e2.message}\\n` +\n          `--- Snippet ---\\n${snip}`\n      );\n    }\n  }\n}\n\nfunction isPlainObject(v) {\n  return v && typeof v === \"object\" && !Array.isArray(v);\n}\n\nfunction isNumericSegment(seg) {\n  return /^-?\\d+$/.test(String(seg));\n}\n\n// ============================\n// ✅ DEEP MERGE (чтобы portsStatus не затирался целиком)\n\nfunction deepMergeObjectsInPlace(dst, src) {\n  if (!isPlainObject(dst) || !isPlainObject(src)) return dst;\n  for (const [k, v] of Object.entries(src)) {\n    if (isPlainObject(v) && isPlainObject(dst[k])) {\n      deepMergeObjectsInPlace(dst[k], v);\n    } else {\n      dst[k] = v;\n    }\n  }\n  return dst;\n}\n\nfunction cloneJson(v) {\n  try {\n    return JSON.parse(JSON.stringify(v));\n  } catch (_) {\n    return v;\n  }\n}\n\n// ============================\n// ✅ MERGE keysToWrite всех item-ов по одному filePath\n\nconst MERGED_KEYS_TO_WRITE_BY_FILEPATH = (() => {\n  const m = new Map();\n  try {\n    for (let i = 0; i < items.length; i++) {\n      const fp = items[i]?.json?.filePath;\n      const key = fp != null ? String(fp) : `__idx_${i}`;\n\n      if (!m.has(key)) {\n        const base = isPlainObject(PATCH_BASE) ? cloneJson(PATCH_BASE) : {};\n        m.set(key, base);\n      }\n\n      const kw = items[i]?.json?.keysToWrite;\n      if (isPlainObject(kw)) {\n        deepMergeObjectsInPlace(m.get(key), kw);\n      }\n    }\n  } catch (_) {}\n\n  return m;\n})();\n\n// ============================\n// PATH PARSING (dot-path + [n] + [-1] + [idx] + [*] + [+n] insert)\n\nfunction parseSelector(selRaw) {\n  const s = String(selRaw).trim();\n  if (!s) return null;\n\n  if (s === \"n\" || s === \"*\") return { kind: \"all\" };\n  if (/^\\+\\d+$/.test(s)) return { kind: \"insert\", index: Number(s.slice(1)) };\n  if (/^-?\\d+$/.test(s)) return { kind: \"index\", index: Number(s) };\n\n  return null;\n}\n\nfunction parsePathPattern(path) {\n  const raw = String(path).trim();\n  if (!raw) return [];\n\n  const dotParts = raw.split(\".\").map(s => s.trim()).filter(Boolean);\n  const steps = [];\n\n  for (const part of dotParts) {\n    // numeric dot segment => array step\n    if (!part.includes(\"[\") && isNumericSegment(part)) {\n      steps.push({ key: null, sel: { kind: \"index\", index: Number(part) } });\n      continue;\n    }\n\n    if (!part.includes(\"[\")) {\n      steps.push({ key: part, sel: null });\n      continue;\n    }\n\n    const firstBracket = part.indexOf(\"[\");\n    const prop = part.slice(0, firstBracket).trim();\n\n    const bracketMatches = [...part.matchAll(/\\[([^\\]]*)\\]/g)].map(m => m[1]);\n\n    // first bracket attaches to property if prop exists, else it's array step\n    if (prop) {\n      const sel0 = parseSelector(bracketMatches[0]);\n      steps.push({ key: prop, sel: sel0 });\n    } else {\n      const sel0 = parseSelector(bracketMatches[0]);\n      if (sel0) steps.push({ key: null, sel: sel0 });\n    }\n\n    // subsequent brackets become array steps\n    for (let i = 1; i < bracketMatches.length; i++) {\n      const sel = parseSelector(bracketMatches[i]);\n      if (sel) steps.push({ key: null, sel });\n    }\n  }\n\n  return steps;\n}\n\nfunction normalizeIndex(idx, length) {\n  let i = Number(idx);\n  if (!Number.isFinite(i)) return null;\n\n  if (i < 0) i = length + i; // -1 => last\n  if (i < 0 || i >= length) return null;\n\n  return i;\n}\n\nfunction nextContainerForStep(nextStep) {\n  return nextStep && nextStep.key == null ? [] : {};\n}\n\n// ============================\n// PROJECTION (keysToReturn) + ✅ NEW \"src:dst\" mapping\n\n// Разбираем строку вида \"proxyServerIP:ip\"\nfunction splitReturnMapping(expr) {\n  const s = String(expr ?? \"\").trim();\n  if (!s) return null;\n\n  const pos = s.indexOf(\":\");\n  if (pos <= 0) return { src: s, dst: null }; // без маппинга\n\n  const src = s.slice(0, pos).trim();\n  const dst = s.slice(pos + 1).trim();\n\n  if (!src) return { src: s, dst: null };\n  if (!dst) return { src, dst: src }; // \"a:\" -> как будто \"a:a\"\n\n  return { src, dst };\n}\n\n// Получить ВСЕ значения по steps (если встретили [*] -> вернём много)\nfunction collectValuesBySteps(node, steps, pos) {\n  if (pos >= steps.length) return [node];\n\n  const step = steps[pos];\n\n  // array step on current\n  if (step.key == null) {\n    if (!Array.isArray(node) || !step.sel) return [];\n\n    if (step.sel.kind === \"all\") {\n      const out = [];\n      for (let i = 0; i < node.length; i++) {\n        out.push(...collectValuesBySteps(node[i], steps, pos + 1));\n      }\n      return out;\n    }\n\n    if (step.sel.kind === \"index\") {\n      const i = normalizeIndex(step.sel.index, node.length);\n      if (i == null) return [];\n      return collectValuesBySteps(node[i], steps, pos + 1);\n    }\n\n    return [];\n  }\n\n  // property step\n  if (node == null || typeof node !== \"object\") return [];\n  if (!Object.prototype.hasOwnProperty.call(node, step.key)) return [];\n\n  const val = node[step.key];\n\n  if (!step.sel) {\n    return collectValuesBySteps(val, steps, pos + 1);\n  }\n\n  if (!Array.isArray(val)) return [];\n\n  if (step.sel.kind === \"all\") {\n    const out = [];\n    for (let i = 0; i < val.length; i++) {\n      out.push(...collectValuesBySteps(val[i], steps, pos + 1));\n    }\n    return out;\n  }\n\n  if (step.sel.kind === \"index\") {\n    const i = normalizeIndex(step.sel.index, val.length);\n    if (i == null) return [];\n    return collectValuesBySteps(val[i], steps, pos + 1);\n  }\n\n  return [];\n}\n\n// Записать значение по dest steps (если value — массив, просто запишем массив)\nfunction setValueBySteps(root, steps, pos, value) {\n  if (pos >= steps.length) return;\n\n  const step = steps[pos];\n\n  // array step on current\n  if (step.key == null) {\n    if (!Array.isArray(root) || !step.sel) return;\n\n    if (step.sel.kind === \"all\") {\n      // пишем во все существующие элементы (если их нет — ничего не делаем)\n      for (let i = 0; i < root.length; i++) {\n        if (pos === steps.length - 1) {\n          root[i] = value;\n        } else {\n          const next = steps[pos + 1];\n          if (root[i] == null || typeof root[i] !== \"object\") {\n            root[i] = nextContainerForStep(next);\n          }\n          setValueBySteps(root[i], steps, pos + 1, value);\n        }\n      }\n      return;\n    }\n\n    if (step.sel.kind === \"index\") {\n      let idx = step.sel.index;\n      if (!Number.isFinite(idx)) return;\n\n      // поддержка -1\n      if (idx < 0) idx = root.length + idx;\n      if (idx < 0) idx = 0;\n\n      while (root.length <= idx) root.push(undefined);\n\n      if (pos === steps.length - 1) {\n        root[idx] = value;\n      } else {\n        const next = steps[pos + 1];\n        if (root[idx] == null || typeof root[idx] !== \"object\") {\n          root[idx] = nextContainerForStep(next);\n        }\n        setValueBySteps(root[idx], steps, pos + 1, value);\n      }\n      return;\n    }\n\n    return;\n  }\n\n  // property step\n  if (root == null || typeof root !== \"object\") return;\n\n  // no selector\n  if (!step.sel) {\n    if (pos === steps.length - 1) {\n      root[step.key] = value;\n      return;\n    }\n\n    const next = steps[pos + 1];\n    const wantsArray = next.key == null;\n\n    if (root[step.key] == null || typeof root[step.key] !== \"object\") {\n      root[step.key] = wantsArray ? [] : {};\n    } else {\n      if (wantsArray && !Array.isArray(root[step.key])) root[step.key] = [];\n      if (!wantsArray && Array.isArray(root[step.key])) root[step.key] = {};\n    }\n\n    setValueBySteps(root[step.key], steps, pos + 1, value);\n    return;\n  }\n\n  // selector on property => property должен быть массивом\n  if (!Array.isArray(root[step.key])) root[step.key] = [];\n  const arr = root[step.key];\n\n  if (step.sel.kind === \"all\") {\n    for (let i = 0; i < arr.length; i++) {\n      if (pos === steps.length - 1) {\n        arr[i] = value;\n      } else {\n        const next = steps[pos + 1];\n        if (arr[i] == null || typeof arr[i] !== \"object\") {\n          arr[i] = nextContainerForStep(next);\n        }\n        setValueBySteps(arr[i], steps, pos + 1, value);\n      }\n    }\n    return;\n  }\n\n  if (step.sel.kind === \"index\") {\n    let idx = step.sel.index;\n    if (!Number.isFinite(idx)) return;\n\n    if (idx < 0) idx = arr.length + idx;\n    if (idx < 0) idx = 0;\n\n    while (arr.length <= idx) arr.push(undefined);\n\n    if (pos === steps.length - 1) {\n      arr[idx] = value;\n    } else {\n      const next = steps[pos + 1];\n      if (arr[idx] == null || typeof arr[idx] !== \"object\") {\n        arr[idx] = nextContainerForStep(next);\n      }\n      setValueBySteps(arr[idx], steps, pos + 1, value);\n    }\n  }\n}\n\n// Старый проектор (без маппинга) оставляем как есть\nfunction applyProjectionPath(outNode, srcNode, steps, pos) {\n  if (pos >= steps.length) return;\n\n  const step = steps[pos];\n\n  // array step on current value\n  if (step.key == null) {\n    if (!Array.isArray(srcNode)) return;\n    if (!Array.isArray(outNode)) return;\n\n    const sel = step.sel;\n    if (!sel) return;\n\n    if (sel.kind === \"all\") {\n      for (let i = 0; i < srcNode.length; i++) {\n        const srcEl = srcNode[i];\n\n        if (pos === steps.length - 1) {\n          outNode[i] = srcEl;\n          continue;\n        }\n\n        if (outNode[i] == null || typeof outNode[i] !== \"object\") {\n          outNode[i] = nextContainerForStep(steps[pos + 1]);\n        } else {\n          if (steps[pos + 1].key == null && !Array.isArray(outNode[i])) outNode[i] = [];\n          if (steps[pos + 1].key != null && Array.isArray(outNode[i])) outNode[i] = {};\n        }\n\n        applyProjectionPath(outNode[i], srcEl, steps, pos + 1);\n      }\n      return;\n    }\n\n    if (sel.kind === \"index\") {\n      const i = normalizeIndex(sel.index, srcNode.length);\n      if (i == null) return;\n      const srcEl = srcNode[i];\n\n      if (pos === steps.length - 1) {\n        outNode.push(srcEl);\n        return;\n      }\n\n      const container = nextContainerForStep(steps[pos + 1]);\n      outNode.push(container);\n      applyProjectionPath(container, srcEl, steps, pos + 1);\n      return;\n    }\n\n    return;\n  }\n\n  // property step\n  if (srcNode == null || typeof srcNode !== \"object\") return;\n  if (!Object.prototype.hasOwnProperty.call(srcNode, step.key)) return;\n\n  const srcVal = srcNode[step.key];\n\n  // no selector\n  if (!step.sel) {\n    if (pos === steps.length - 1) {\n      outNode[step.key] = srcVal;\n      return;\n    }\n\n    const next = steps[pos + 1];\n    const wanted = nextContainerForStep(next);\n\n    if (outNode[step.key] == null || typeof outNode[step.key] !== \"object\") {\n      outNode[step.key] = wanted;\n    } else {\n      if (next.key == null && !Array.isArray(outNode[step.key])) outNode[step.key] = [];\n      if (next.key != null && Array.isArray(outNode[step.key])) outNode[step.key] = {};\n    }\n\n    applyProjectionPath(outNode[step.key], srcVal, steps, pos + 1);\n    return;\n  }\n\n  // selector on property\n  if (!Array.isArray(srcVal)) return;\n\n  if (step.sel.kind === \"all\") {\n    if (!Array.isArray(outNode[step.key])) outNode[step.key] = [];\n    const outArr = outNode[step.key];\n\n    for (let i = 0; i < srcVal.length; i++) {\n      const srcEl = srcVal[i];\n\n      if (pos === steps.length - 1) {\n        outArr[i] = srcEl;\n        continue;\n      }\n\n      const next = steps[pos + 1];\n      const wanted = nextContainerForStep(next);\n\n      if (outArr[i] == null || typeof outArr[i] !== \"object\") {\n        outArr[i] = wanted;\n      } else {\n        if (next.key == null && !Array.isArray(outArr[i])) outArr[i] = [];\n        if (next.key != null && Array.isArray(outArr[i])) outArr[i] = {};\n      }\n\n      applyProjectionPath(outArr[i], srcEl, steps, pos + 1);\n    }\n\n    return;\n  }\n\n  if (step.sel.kind === \"index\") {\n    const i = normalizeIndex(step.sel.index, srcVal.length);\n    if (i == null) return;\n\n    if (!Array.isArray(outNode[step.key])) outNode[step.key] = [];\n    const outArr = outNode[step.key];\n    const srcEl = srcVal[i];\n\n    if (pos === steps.length - 1) {\n      outArr.push(srcEl);\n      return;\n    }\n\n    const container = nextContainerForStep(steps[pos + 1]);\n    outArr.push(container);\n    applyProjectionPath(container, srcEl, steps, pos + 1);\n    return;\n  }\n}\n\nfunction projectObjectByKeys(src, onlyKeys) {\n  if (!onlyKeys || !onlyKeys.length) return src;\n\n  if (Array.isArray(src)) {\n    return src.map(el => projectObjectByKeys(el, onlyKeys));\n  }\n\n  if (!isPlainObject(src)) return src;\n\n  const out = {};\n  for (const kRaw of onlyKeys) {\n    const m = splitReturnMapping(kRaw);\n    if (!m) continue;\n\n    const srcPath = String(m.src).trim();\n    if (!srcPath) continue;\n\n    // ✅ обычный режим (как было)\n    if (!m.dst) {\n      const steps = parsePathPattern(srcPath);\n      if (!steps.length) continue;\n      applyProjectionPath(out, src, steps, 0);\n      continue;\n    }\n\n    // ✅ режим \"src:dst\"\n    const dstPath = String(m.dst).trim();\n    if (!dstPath) continue;\n\n    const srcSteps = parsePathPattern(srcPath);\n    const dstSteps = parsePathPattern(dstPath);\n    if (!srcSteps.length || !dstSteps.length) continue;\n\n    const values = collectValuesBySteps(src, srcSteps, 0);\n    if (!values.length) continue;\n\n    const valToSet = values.length === 1 ? values[0] : values;\n    setValueBySteps(out, dstSteps, 0, valToSet);\n  }\n  return out;\n}\n\n// ============================\n// DELETE (keysToDelete) — dot-path + [] + [n]/[-1]/[idx]\n\nfunction deleteBySteps(root, steps, pos) {\n  if (pos >= steps.length) return;\n\n  const step = steps[pos];\n\n  // array step on current\n  if (step.key == null) {\n    if (!Array.isArray(root) || !step.sel) return;\n\n    if (step.sel.kind === \"all\") {\n      for (let i = 0; i < root.length; i++) {\n        if (pos === steps.length - 1) {\n          root.splice(i, 1);\n          i--;\n        } else {\n          deleteBySteps(root[i], steps, pos + 1);\n        }\n      }\n      return;\n    }\n\n    if (step.sel.kind === \"index\") {\n      let idx = step.sel.index;\n      if (!Number.isFinite(idx)) return;\n      if (idx < 0) idx = root.length + idx;\n      if (idx < 0 || idx >= root.length) return;\n\n      if (pos === steps.length - 1) {\n        root.splice(idx, 1);\n      } else {\n        deleteBySteps(root[idx], steps, pos + 1);\n      }\n      return;\n    }\n\n    return;\n  }\n\n  // property step\n  if (root == null || typeof root !== \"object\") return;\n  if (!Object.prototype.hasOwnProperty.call(root, step.key)) return;\n\n  // no selector\n  if (!step.sel) {\n    if (pos === steps.length - 1) {\n      delete root[step.key];\n      return;\n    }\n    deleteBySteps(root[step.key], steps, pos + 1);\n    return;\n  }\n\n  // selector on property\n  const val = root[step.key];\n  if (!Array.isArray(val)) return;\n\n  if (step.sel.kind === \"all\") {\n    if (pos === steps.length - 1) {\n      delete root[step.key];\n      return;\n    }\n    for (let i = 0; i < val.length; i++) {\n      deleteBySteps(val[i], steps, pos + 1);\n    }\n    return;\n  }\n\n  if (step.sel.kind === \"index\") {\n    let idx = step.sel.index;\n    if (!Number.isFinite(idx)) return;\n    if (idx < 0) idx = val.length + idx;\n    if (idx < 0 || idx >= val.length) return;\n\n    if (pos === steps.length - 1) {\n      val.splice(idx, 1);\n      return;\n    }\n    deleteBySteps(val[idx], steps, pos + 1);\n    return;\n  }\n}\n\nfunction deleteKeysByPaths(root, keysToDelete) {\n  if (!keysToDelete || !Array.isArray(keysToDelete) || !keysToDelete.length) return root;\n\n  // если root — массив, применяем ко всем элементам\n  if (Array.isArray(root)) {\n    for (let i = 0; i < root.length; i++) {\n      deleteKeysByPaths(root[i], keysToDelete);\n    }\n    return root;\n  }\n\n  if (!isPlainObject(root)) return root;\n\n  for (const kRaw of keysToDelete) {\n    const k = String(kRaw).trim();\n    if (!k) continue;\n    const steps = parsePathPattern(k);\n    if (!steps.length) continue;\n    deleteBySteps(root, steps, 0);\n  }\n\n  return root;\n}\n\n// ============================\n// PATCH APPLY (dot-path + [] + [n] + [+n])\n\nfunction ensureArrayContainer(v) {\n  if (Array.isArray(v)) return v;\n  return [];\n}\n\nfunction applyPatchPath(target, steps, pos, value) {\n  if (pos >= steps.length) return;\n\n  const step = steps[pos];\n\n  // array step on current\n  if (step.key == null) {\n    if (!Array.isArray(target)) return;\n    const sel = step.sel;\n    if (!sel) return;\n\n    // ✅ insert with shift: [ +n ]\n    if (sel.kind === \"insert\") {\n      let ins = Number(sel.index);\n      if (!Number.isFinite(ins)) return;\n      if (ins < 0) ins = 0;\n      if (ins > target.length) ins = target.length;\n\n      if (pos === steps.length - 1) {\n        target.splice(ins, 0, value);\n        return;\n      }\n\n      const next = steps[pos + 1];\n      const container = nextContainerForStep(next);\n      target.splice(ins, 0, container);\n      applyPatchPath(container, steps, pos + 1, value);\n      return;\n    }\n\n    if (sel.kind === \"all\") {\n      for (let i = 0; i < target.length; i++) {\n        if (pos === steps.length - 1) {\n          target[i] = value;\n          continue;\n        }\n        const next = steps[pos + 1];\n        if (target[i] == null || typeof target[i] !== \"object\") {\n          target[i] = nextContainerForStep(next);\n        }\n        applyPatchPath(target[i], steps, pos + 1, value);\n      }\n      return;\n    }\n\n    if (sel.kind === \"index\") {\n      let idx = sel.index;\n      if (!Number.isFinite(idx)) return;\n\n      if (idx < 0) idx = target.length + idx;\n      if (idx < 0) idx = 0;\n\n      while (target.length <= idx) target.push(undefined);\n\n      if (pos === steps.length - 1) {\n        target[idx] = value;\n        return;\n      }\n\n      const next = steps[pos + 1];\n      if (target[idx] == null || typeof target[idx] !== \"object\") {\n        target[idx] = nextContainerForStep(next);\n      }\n      applyPatchPath(target[idx], steps, pos + 1, value);\n      return;\n    }\n\n    return;\n  }\n\n  // property step\n  if (target == null || typeof target !== \"object\") return;\n\n  if (!step.sel) {\n    if (pos === steps.length - 1) {\n      // ✅ если оба объекта — мерджим, а не перезатираем\n      if (isPlainObject(value) && isPlainObject(target[step.key])) {\n        deepMergeObjectsInPlace(target[step.key], value);\n      } else {\n        target[step.key] = value;\n      }\n      return;\n    }\n\n    const next = steps[pos + 1];\n    const wantsArray = next.key == null;\n\n    if (target[step.key] == null || typeof target[step.key] !== \"object\") {\n      target[step.key] = wantsArray ? [] : {};\n    } else {\n      if (wantsArray && !Array.isArray(target[step.key])) target[step.key] = [];\n      if (!wantsArray && Array.isArray(target[step.key])) target[step.key] = {};\n    }\n\n    applyPatchPath(target[step.key], steps, pos + 1, value);\n    return;\n  }\n\n  target[step.key] = ensureArrayContainer(target[step.key]);\n  const arr = target[step.key];\n\n  // ✅ insert with shift for property-array: prop[+n]\n  if (step.sel.kind === \"insert\") {\n    let ins = Number(step.sel.index);\n    if (!Number.isFinite(ins)) return;\n    if (ins < 0) ins = 0;\n    if (ins > arr.length) ins = arr.length;\n\n    if (pos === steps.length - 1) {\n      arr.splice(ins, 0, value);\n      return;\n    }\n\n    const next = steps[pos + 1];\n    const container = nextContainerForStep(next);\n    arr.splice(ins, 0, container);\n    applyPatchPath(container, steps, pos + 1, value);\n    return;\n  }\n\n  if (step.sel.kind === \"all\") {\n    for (let i = 0; i < arr.length; i++) {\n      if (pos === steps.length - 1) {\n        arr[i] = value;\n        continue;\n      }\n      const next = steps[pos + 1];\n      if (arr[i] == null || typeof arr[i] !== \"object\") {\n        arr[i] = nextContainerForStep(next);\n      }\n      applyPatchPath(arr[i], steps, pos + 1, value);\n    }\n    return;\n  }\n\n  if (step.sel.kind === \"index\") {\n    let idx = step.sel.index;\n    if (!Number.isFinite(idx)) return;\n\n    if (idx < 0) idx = arr.length + idx;\n    if (idx < 0) idx = 0;\n\n    while (arr.length <= idx) arr.push(undefined);\n\n    if (pos === steps.length - 1) {\n      arr[idx] = value;\n      return;\n    }\n\n    const next = steps[pos + 1];\n    if (arr[idx] == null || typeof arr[idx] !== \"object\") {\n      arr[idx] = nextContainerForStep(next);\n    }\n    applyPatchPath(arr[idx], steps, pos + 1, value);\n    return;\n  }\n}\n\nfunction applyPatchToAny(root, patch) {\n  if (!patch || typeof patch !== \"object\") return root;\n\n  if (Array.isArray(root)) {\n    for (let i = 0; i < root.length; i++) {\n      if (root[i] && typeof root[i] === \"object\") {\n        applyPatchToAny(root[i], patch);\n      }\n    }\n    return root;\n  }\n\n  if (!isPlainObject(root)) return root;\n\n  for (const [kRaw, v] of Object.entries(patch)) {\n    if (v === undefined) continue;\n    const k = String(kRaw).trim();\n    if (!k) continue;\n\n    const steps = parsePathPattern(k);\n    if (!steps.length) continue;\n\n    applyPatchPath(root, steps, 0, v);\n  }\n\n  return root;\n}\n\n// ============================\n// OTHER HELPERS\n\nfunction buildPatchForItem(item, idx) {\n  const fp = item.json?.filePath;\n  const key = fp != null ? String(fp) : `__idx_${idx}`;\n\n  const merged = MERGED_KEYS_TO_WRITE_BY_FILEPATH.get(key);\n  const patch = isPlainObject(merged)\n    ? cloneJson(merged)\n    : (isPlainObject(PATCH_BASE) ? cloneJson(PATCH_BASE) : {});\n\n  const extraPatch = item.json?.patch ?? $input.first()?.json?.patch;\n  if (isPlainObject(extraPatch)) {\n    deepMergeObjectsInPlace(patch, extraPatch);\n  }\n\n  return patch;\n}\n\nfunction resolveOnlyKeys(item) {\n  const keys =\n    item.json?.onlyKeys ??\n    $input.first()?.json?.onlyKeys ??\n    ONLY_KEYS_FALLBACK;\n\n  if (!Array.isArray(keys)) return null;\n  const cleaned = keys.map(k => String(k).trim()).filter(Boolean);\n  return cleaned.length ? cleaned : null;\n}\n\nfunction resolveKeysToDelete(item) {\n  const keys =\n    item.json?.keysToDelete ??\n    $input.first()?.json?.keysToDelete ??\n    KEYS_TO_DELETE;\n\n  if (!Array.isArray(keys)) return null;\n  const cleaned = keys.map(k => String(k).trim()).filter(Boolean);\n  return cleaned.length ? cleaned : null;\n}\n\nfunction resolveReturnBinary(item) {\n  if (item.json?.returnBinary !== undefined) return Boolean(item.json.returnBinary);\n  const g = $input.first()?.json?.returnBinary;\n  if (g !== undefined) return Boolean(g);\n  return Boolean(RETURN_BINARY_FALLBACK);\n}\n\nfunction resolveReturnJson(item) {\n  if (item.json?.returnJson !== undefined) return Boolean(item.json.returnJson);\n  const g = $input.first()?.json?.returnJson;\n  if (g !== undefined) return Boolean(g);\n  return Boolean(RETURN_JSON_FALLBACK);\n}\n\nfunction resolveReplaceWholeJson(item) {\n  if (item.json?.replaceWholeJson !== undefined) return Boolean(item.json.replaceWholeJson);\n  const g = $input.first()?.json?.replaceWholeJson;\n  if (g !== undefined) return Boolean(g);\n  return Boolean(REPLACE_WHOLE_JSON_FALLBACK);\n}\n\nfunction getReplaceJson(item) {\n  const v = item.json?.replaceJson ?? $input.first()?.json?.replaceJson;\n  return v !== undefined ? v : DEFAULT_REPLACE_JSON;\n}\n\nfunction getSourceItemForIndexSafe(idx) {\n  try {\n    if (!SOURCE_NODE) return items[idx] ?? null;\n\n    try {\n      const m = $(SOURCE_NODE).itemMatching(idx);\n      if (m) return m;\n    } catch (_) {}\n\n    try {\n      const all = $(SOURCE_NODE).all();\n      if (all?.[idx]) return all[idx];\n    } catch (_) {}\n\n    // ✅ fallback если source-node отдал 1 item, а текущих items много\n    try {\n      return $(SOURCE_NODE).first() ?? null;\n    } catch (_) {}\n\n    return null;\n  } catch (_) {\n    return null;\n  }\n}\n\nfunction pickBinKeySafe(srcItem) {\n  try {\n    if (SOURCE_BIN_KEY) return SOURCE_BIN_KEY;\n    const keys = Object.keys(srcItem?.binary || {});\n    return keys[0] || \"\";\n  } catch (_) {\n    return \"\";\n  }\n}\n\nfunction hasBinaryPayload(srcItem, binKey) {\n  try {\n    if (!srcItem?.binary?.[binKey]) return false;\n    const b = srcItem.binary[binKey];\n    if (typeof b.data === \"string\" && b.data.length > 0) return true;\n    return false;\n  } catch (_) {\n    return false;\n  }\n}\n\nfunction shouldWriteEmptyFile(jsonObj) {\n  if (!jsonObj) return true;\n  if (isPlainObject(jsonObj)) return Object.keys(jsonObj).length === 0;\n  if (Array.isArray(jsonObj)) return jsonObj.length === 0;\n  return false;\n}\n\nfunction applyReturnJsonFlag(result, shouldReturnJson) {\n  if (!shouldReturnJson) result.json = {};\n  return result;\n}\n\nfunction makeFallbackJson(item, idx) {\n  const json = {};\n  const patch = buildPatchForItem(item, idx);\n  applyPatchToAny(json, patch);\n\n  const keysToDelete = resolveKeysToDelete(item);\n  deleteKeysByPaths(json, keysToDelete);\n\n  const onlyKeys = resolveOnlyKeys(item);\n  return projectObjectByKeys(json, onlyKeys);\n}\n\n// ============================\n// MAIN\n\nreturn await Promise.all(\n  items.map(async (item, idx) => {\n    const shouldReturnBinary = resolveReturnBinary(item);\n    const shouldReturnJson = resolveReturnJson(item);\n    const shouldReplaceWholeJson = resolveReplaceWholeJson(item);\n\n    // ====== РЕЖИМ ПОЛНОЙ ЗАМЕНЫ JSON ======\n    if (shouldReplaceWholeJson) {\n      let json = getReplaceJson(item);\n      if (!isPlainObject(json) && !Array.isArray(json)) json = {};\n\n      const keysToDelete = resolveKeysToDelete(item);\n      deleteKeysByPaths(json, keysToDelete);\n\n      const onlyKeys = resolveOnlyKeys(item);\n      json = projectObjectByKeys(json, onlyKeys);\n\n      const result = { json, pairedItem: idx };\n\n      if (shouldReturnBinary) {\n        const fileName =\n          (item.json?.fileName && String(item.json.fileName).trim()) ||\n          DEFAULT_OUT_FILE;\n\n        const outText = shouldWriteEmptyFile(json) ? \"\" : (JSON.stringify(json, null, 2) + \"\\n\");\n        const outBuf = Buffer.from(outText, \"utf8\");\n\n        const binaryData = await this.helpers.prepareBinaryData(\n          outBuf,\n          fileName,\n          \"application/json\"\n        );\n\n        result.binary = { data: binaryData };\n      }\n\n      return applyReturnJsonFlag(result, shouldReturnJson);\n    }\n\n    // ====== ОБЫЧНЫЙ РЕЖИМ ======\n\n    const srcItem = getSourceItemForIndexSafe(idx);\n    const binKey = pickBinKeySafe(srcItem);\n\n    if (!srcItem || !binKey || !hasBinaryPayload(srcItem, binKey)) {\n      const json = makeFallbackJson(item, idx);\n\n      const result = { json, pairedItem: idx };\n\n      if (shouldReturnBinary) {\n        const fileName =\n          (item.json?.fileName && String(item.json.fileName).trim()) ||\n          srcItem?.binary?.[binKey]?.fileName ||\n          DEFAULT_OUT_FILE;\n\n        const outText = shouldWriteEmptyFile(json) ? \"\" : (JSON.stringify(json, null, 2) + \"\\n\");\n        const outBuf = Buffer.from(outText, \"utf8\");\n\n        const binaryData = await this.helpers.prepareBinaryData(\n          outBuf,\n          fileName,\n          \"application/json\"\n        );\n\n        result.binary = { data: binaryData };\n      }\n\n      return applyReturnJsonFlag(result, shouldReturnJson);\n    }\n\n    try {\n      if (SOURCE_NODE) {\n        item.binary = item.binary || {};\n        item.binary[binKey] = srcItem.binary[binKey];\n      }\n    } catch (_) {}\n\n    let text = \"\";\n    try {\n      const buf = await this.helpers.getBinaryDataBuffer(idx, binKey);\n      if (buf && buf.length) text = buf.toString(\"utf8\");\n    } catch (_) {}\n\n    if (!text || !String(text).trim()) {\n      const json = makeFallbackJson(item, idx);\n\n      const result = { json, pairedItem: idx };\n\n      if (shouldReturnBinary) {\n        const fileName =\n          (item.json?.fileName && String(item.json.fileName).trim()) ||\n          srcItem.binary?.[binKey]?.fileName ||\n          DEFAULT_OUT_FILE;\n\n        const outText = shouldWriteEmptyFile(json) ? \"\" : (JSON.stringify(json, null, 2) + \"\\n\");\n        const outBuf = Buffer.from(outText, \"utf8\");\n\n        const binaryData = await this.helpers.prepareBinaryData(\n          outBuf,\n          fileName,\n          \"application/json\"\n        );\n\n        result.binary = { data: binaryData };\n      }\n\n      return applyReturnJsonFlag(result, shouldReturnJson);\n    }\n\n    let json;\n    try {\n      json = parseJsonLenient(text, idx);\n      if (!isPlainObject(json) && !Array.isArray(json)) json = {};\n    } catch (_) {\n      json = {};\n    }\n\n    const patch = buildPatchForItem(item, idx);\n\n    if (isPlainObject(json) || Array.isArray(json)) {\n      applyPatchToAny(json, patch);\n    } else {\n      json = makeFallbackJson(item, idx);\n    }\n\n    const keysToDelete = resolveKeysToDelete(item);\n    deleteKeysByPaths(json, keysToDelete);\n\n    const onlyKeys = resolveOnlyKeys(item);\n    json = projectObjectByKeys(json, onlyKeys);\n\n    const result = { json, pairedItem: idx };\n\n    if (shouldReturnBinary) {\n      const fileName =\n        (item.json?.fileName && String(item.json.fileName).trim()) ||\n        srcItem.binary?.[binKey]?.fileName ||\n        DEFAULT_OUT_FILE;\n\n      const outText = shouldWriteEmptyFile(json) ? \"\" : (JSON.stringify(json, null, 2) + \"\\n\");\n      const outBuf = Buffer.from(outText, \"utf8\");\n\n      const binaryData = await this.helpers.prepareBinaryData(\n        outBuf,\n        fileName,\n        \"application/json\"\n      );\n\n      result.binary = { data: binaryData };\n    }\n\n    return applyReturnJsonFlag(result, shouldReturnJson);\n  })\n);\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        848,
        16
      ],
      "id": "1366f982-cb3b-4b7a-8d32-00d7f74e4816",
      "name": "Return Binary With New Fields"
    },
    {
      "parameters": {
        "operation": "write",
        "fileName": "={{ $('Start').first().json.filePath }}",
        "options": {}
      },
      "type": "n8n-nodes-base.readWriteFile",
      "typeVersion": 1,
      "position": [
        1088,
        16
      ],
      "id": "f0ee5ac3-7d07-4bd9-8af8-dbefd17f1066",
      "name": "Write JSON File",
      "alwaysOutputData": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "8dd072d2-0df2-4fbd-8354-4708ccc2adda",
                    "leftValue": "={{ !$json.hasField('error') }}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "success"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.hasField('error') ? $json.error == \"The file or directory does not exist\" : false }}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "id": "fae4d163-de55-4713-b542-67924a042eed"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "path not exist"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.4,
      "position": [
        1280,
        16
      ],
      "id": "f3930116-4cb3-4a9b-8d1f-4f03f9c6e3f4",
      "name": "Switch1"
    },
    {
      "parameters": {
        "command": "=powershell -Command \"New-Item -ItemType File -Path '{{ $('Start').first().json.filePath }}' -Force | Out-Null\""
      },
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        1376,
        112
      ],
      "id": "65b2dbde-edcd-4264-90a8-cdd257f99f18",
      "name": "Create File"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1520,
        16
      ],
      "id": "dfe363e5-1e21-4ce9-948a-adb9cecfbeb5",
      "name": "empty out"
    },
    {
      "parameters": {
        "command": "=powershell -Command \"Remove-Item -Path '{{ $('Start').first().json.filePath }}' -Force -ErrorAction SilentlyContinue\""
      },
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        848,
        176
      ],
      "id": "a3c5c723-f3d2-4354-a419-2eb167bb5eb4",
      "name": "Delete File"
    },
    {
      "parameters": {
        "jsCode": "// ============================\n// НАСТРОЙКИ\n\n// Если бинарник с JSON лежит в ДРУГОЙ ноде — укажи её имя (ТОЧНО как в n8n).\n// Если бинарник уже приходит на вход этой Code-ноды — оставь пустую строку.\nconst SOURCE_NODE = \"Read JSON File\";\n\n// Имя бинарного поля (обычно \"data\"). Пусто = возьмём первый ключ из binary.\nconst SOURCE_BIN_KEY = \"\";\n\n// Выходное имя файла, если не удалось взять из входного бинарника / item.json.fileName\nconst DEFAULT_OUT_FILE = \"updated.json\";\n\n// Дефолтный патч — обновляем ТОЛЬКО эти поля. Остальные поля входного JSON не трогаем.\nconst PATCH_BASE = $('Start').first().json.keysToWrite;\n\n// Белый список ключей, которые нужно ОСТАВИТЬ на выходе (dot-path поддерживается).\n// Если пусто/нет — не фильтруем.\nconst ONLY_KEYS_FALLBACK = $('Start').first().json.keysToReturn;\n\n// ✅ Чёрный список ключей, которые нужно УДАЛИТЬ (dot-path + [n]/[-1]/[idx] поддерживается).\n// Если пусто/нет — ничего не удаляем.\nconst KEYS_TO_DELETE = $('Start').first().json.keysToDelete;\n\n// Возвращать ли бинарник (по умолчанию true).\nconst RETURN_BINARY_FALLBACK = false;\n\n// Возвращать ли json в output items (по умолчанию true).\n// Важно: n8n требует поле json, поэтому если returnJson=false -> json будет {}\nconst RETURN_JSON_FALLBACK = true;\n\n// Полностью перезаписать JSON на то, что подаёшь на входе.\nconst REPLACE_WHOLE_JSON_FALLBACK = false;\n\n// Дефолтный “новый JSON” для полной замены, если на входе replaceJson не передали.\nconst DEFAULT_REPLACE_JSON = {};\n\n// ============================\n// HELPERS\n\nfunction removeBom(s) {\n  return String(s).replace(/^\\uFEFF/, \"\");\n}\n\nfunction stripJsonCommentsAndTrailingCommas(s) {\n  let t = removeBom(s);\n\n  // remove // comments\n  t = t.replace(/\\/\\/.*$/gm, \"\");\n\n  // remove /* */ comments\n  t = t.replace(/\\/\\*[\\s\\S]*?\\*\\//g, \"\");\n\n  // remove trailing commas before } or ]\n  t = t.replace(/,(\\s*[}\\]])/g, \"$1\");\n\n  return t.trim();\n}\n\nfunction extractPosFromJsonError(msg) {\n  const m = String(msg).match(/position\\s+(\\d+)/i);\n  return m ? Number(m[1]) : null;\n}\n\nfunction snippetAround(text, pos, radius = 160) {\n  if (pos == null || !Number.isFinite(pos)) {\n    const head = text.slice(0, 400);\n    return `${head}\\n^ (no position info)`;\n  }\n  const start = Math.max(0, pos - radius);\n  const end = Math.min(text.length, pos + radius);\n  const head = start > 0 ? \"… \" : \"\";\n  const tail = end < text.length ? \" …\" : \"\";\n  const slice = text.slice(start, end);\n  const caret = \" \".repeat(Math.max(0, pos - start)) + \"^\";\n  return `${head}${slice}${tail}\\n${caret}`;\n}\n\nfunction parseJsonLenient(rawText, idx) {\n  try {\n    return JSON.parse(removeBom(rawText));\n  } catch (e1) {\n    const cleaned = stripJsonCommentsAndTrailingCommas(rawText);\n    try {\n      return JSON.parse(cleaned);\n    } catch (e2) {\n      const pos = extractPosFromJsonError(e2.message) ?? extractPosFromJsonError(e1.message);\n      const snip = snippetAround(cleaned, pos);\n      throw new Error(\n        `Invalid JSON in binary (item ${idx}).\\n` +\n          `Original parse error: ${e1.message}\\n` +\n          `After comment-strip parse error: ${e2.message}\\n` +\n          `--- Snippet ---\\n${snip}`\n      );\n    }\n  }\n}\n\nfunction isPlainObject(v) {\n  return v && typeof v === \"object\" && !Array.isArray(v);\n}\n\nfunction isNumericSegment(seg) {\n  return /^-?\\d+$/.test(String(seg));\n}\n\n// ============================\n// ✅ DEEP MERGE (чтобы portsStatus не затирался целиком)\n\nfunction deepMergeObjectsInPlace(dst, src) {\n  if (!isPlainObject(dst) || !isPlainObject(src)) return dst;\n  for (const [k, v] of Object.entries(src)) {\n    if (isPlainObject(v) && isPlainObject(dst[k])) {\n      deepMergeObjectsInPlace(dst[k], v);\n    } else {\n      dst[k] = v;\n    }\n  }\n  return dst;\n}\n\nfunction cloneJson(v) {\n  try {\n    return JSON.parse(JSON.stringify(v));\n  } catch (_) {\n    return v;\n  }\n}\n\n// ============================\n// ✅ MERGE keysToWrite всех item-ов по одному filePath\n\nconst MERGED_KEYS_TO_WRITE_BY_FILEPATH = (() => {\n  const m = new Map();\n  try {\n    for (let i = 0; i < items.length; i++) {\n      const fp = items[i]?.json?.filePath;\n      const key = fp != null ? String(fp) : `__idx_${i}`;\n\n      if (!m.has(key)) {\n        const base = isPlainObject(PATCH_BASE) ? cloneJson(PATCH_BASE) : {};\n        m.set(key, base);\n      }\n\n      const kw = items[i]?.json?.keysToWrite;\n      if (isPlainObject(kw)) {\n        deepMergeObjectsInPlace(m.get(key), kw);\n      }\n    }\n  } catch (_) {}\n\n  return m;\n})();\n\n// ============================\n// PATH PARSING (dot-path + [n] + [-1] + [idx] + [*])\n\nfunction parseSelector(selRaw) {\n  const s = String(selRaw).trim();\n  if (!s) return null;\n\n  if (s === \"n\" || s === \"*\") return { kind: \"all\" };\n  if (/^-?\\d+$/.test(s)) return { kind: \"index\", index: Number(s) };\n\n  return null;\n}\n\nfunction parsePathPattern(path) {\n  const raw = String(path).trim();\n  if (!raw) return [];\n\n  const dotParts = raw.split(\".\").map(s => s.trim()).filter(Boolean);\n  const steps = [];\n\n  for (const part of dotParts) {\n    // numeric dot segment => array step\n    if (!part.includes(\"[\") && isNumericSegment(part)) {\n      steps.push({ key: null, sel: { kind: \"index\", index: Number(part) } });\n      continue;\n    }\n\n    if (!part.includes(\"[\")) {\n      steps.push({ key: part, sel: null });\n      continue;\n    }\n\n    const firstBracket = part.indexOf(\"[\");\n    const prop = part.slice(0, firstBracket).trim();\n\n    const bracketMatches = [...part.matchAll(/\\[([^\\]]*)\\]/g)].map(m => m[1]);\n\n    // first bracket attaches to property if prop exists, else it's array step\n    if (prop) {\n      const sel0 = parseSelector(bracketMatches[0]);\n      steps.push({ key: prop, sel: sel0 });\n    } else {\n      const sel0 = parseSelector(bracketMatches[0]);\n      if (sel0) steps.push({ key: null, sel: sel0 });\n    }\n\n    // subsequent brackets become array steps\n    for (let i = 1; i < bracketMatches.length; i++) {\n      const sel = parseSelector(bracketMatches[i]);\n      if (sel) steps.push({ key: null, sel });\n    }\n  }\n\n  return steps;\n}\n\nfunction normalizeIndex(idx, length) {\n  let i = Number(idx);\n  if (!Number.isFinite(i)) return null;\n\n  if (i < 0) i = length + i; // -1 => last\n  if (i < 0 || i >= length) return null;\n\n  return i;\n}\n\nfunction nextContainerForStep(nextStep) {\n  return nextStep && nextStep.key == null ? [] : {};\n}\n\n// ============================\n// PROJECTION (keysToReturn) + ✅ NEW \"src:dst\" mapping\n\n// Разбираем строку вида \"proxyServerIP:ip\"\nfunction splitReturnMapping(expr) {\n  const s = String(expr ?? \"\").trim();\n  if (!s) return null;\n\n  const pos = s.indexOf(\":\");\n  if (pos <= 0) return { src: s, dst: null }; // без маппинга\n\n  const src = s.slice(0, pos).trim();\n  const dst = s.slice(pos + 1).trim();\n\n  if (!src) return { src: s, dst: null };\n  if (!dst) return { src, dst: src }; // \"a:\" -> как будто \"a:a\"\n\n  return { src, dst };\n}\n\n// Получить ВСЕ значения по steps (если встретили [*] -> вернём много)\nfunction collectValuesBySteps(node, steps, pos) {\n  if (pos >= steps.length) return [node];\n\n  const step = steps[pos];\n\n  // array step on current\n  if (step.key == null) {\n    if (!Array.isArray(node) || !step.sel) return [];\n\n    if (step.sel.kind === \"all\") {\n      const out = [];\n      for (let i = 0; i < node.length; i++) {\n        out.push(...collectValuesBySteps(node[i], steps, pos + 1));\n      }\n      return out;\n    }\n\n    if (step.sel.kind === \"index\") {\n      const i = normalizeIndex(step.sel.index, node.length);\n      if (i == null) return [];\n      return collectValuesBySteps(node[i], steps, pos + 1);\n    }\n\n    return [];\n  }\n\n  // property step\n  if (node == null || typeof node !== \"object\") return [];\n  if (!Object.prototype.hasOwnProperty.call(node, step.key)) return [];\n\n  const val = node[step.key];\n\n  if (!step.sel) {\n    return collectValuesBySteps(val, steps, pos + 1);\n  }\n\n  if (!Array.isArray(val)) return [];\n\n  if (step.sel.kind === \"all\") {\n    const out = [];\n    for (let i = 0; i < val.length; i++) {\n      out.push(...collectValuesBySteps(val[i], steps, pos + 1));\n    }\n    return out;\n  }\n\n  if (step.sel.kind === \"index\") {\n    const i = normalizeIndex(step.sel.index, val.length);\n    if (i == null) return [];\n    return collectValuesBySteps(val[i], steps, pos + 1);\n  }\n\n  return [];\n}\n\n// Записать значение по dest steps (если value — массив, просто запишем массив)\nfunction setValueBySteps(root, steps, pos, value) {\n  if (pos >= steps.length) return;\n\n  const step = steps[pos];\n\n  // array step on current\n  if (step.key == null) {\n    if (!Array.isArray(root) || !step.sel) return;\n\n    if (step.sel.kind === \"all\") {\n      // пишем во все существующие элементы (если их нет — ничего не делаем)\n      for (let i = 0; i < root.length; i++) {\n        if (pos === steps.length - 1) {\n          root[i] = value;\n        } else {\n          const next = steps[pos + 1];\n          if (root[i] == null || typeof root[i] !== \"object\") {\n            root[i] = nextContainerForStep(next);\n          }\n          setValueBySteps(root[i], steps, pos + 1, value);\n        }\n      }\n      return;\n    }\n\n    if (step.sel.kind === \"index\") {\n      let idx = step.sel.index;\n      if (!Number.isFinite(idx)) return;\n\n      // поддержка -1\n      if (idx < 0) idx = root.length + idx;\n      if (idx < 0) idx = 0;\n\n      while (root.length <= idx) root.push(undefined);\n\n      if (pos === steps.length - 1) {\n        root[idx] = value;\n      } else {\n        const next = steps[pos + 1];\n        if (root[idx] == null || typeof root[idx] !== \"object\") {\n          root[idx] = nextContainerForStep(next);\n        }\n        setValueBySteps(root[idx], steps, pos + 1, value);\n      }\n      return;\n    }\n\n    return;\n  }\n\n  // property step\n  if (root == null || typeof root !== \"object\") return;\n\n  // no selector\n  if (!step.sel) {\n    if (pos === steps.length - 1) {\n      root[step.key] = value;\n      return;\n    }\n\n    const next = steps[pos + 1];\n    const wantsArray = next.key == null;\n\n    if (root[step.key] == null || typeof root[step.key] !== \"object\") {\n      root[step.key] = wantsArray ? [] : {};\n    } else {\n      if (wantsArray && !Array.isArray(root[step.key])) root[step.key] = [];\n      if (!wantsArray && Array.isArray(root[step.key])) root[step.key] = {};\n    }\n\n    setValueBySteps(root[step.key], steps, pos + 1, value);\n    return;\n  }\n\n  // selector on property => property должен быть массивом\n  if (!Array.isArray(root[step.key])) root[step.key] = [];\n  const arr = root[step.key];\n\n  if (step.sel.kind === \"all\") {\n    for (let i = 0; i < arr.length; i++) {\n      if (pos === steps.length - 1) {\n        arr[i] = value;\n      } else {\n        const next = steps[pos + 1];\n        if (arr[i] == null || typeof arr[i] !== \"object\") {\n          arr[i] = nextContainerForStep(next);\n        }\n        setValueBySteps(arr[i], steps, pos + 1, value);\n      }\n    }\n    return;\n  }\n\n  if (step.sel.kind === \"index\") {\n    let idx = step.sel.index;\n    if (!Number.isFinite(idx)) return;\n\n    if (idx < 0) idx = arr.length + idx;\n    if (idx < 0) idx = 0;\n\n    while (arr.length <= idx) arr.push(undefined);\n\n    if (pos === steps.length - 1) {\n      arr[idx] = value;\n    } else {\n      const next = steps[pos + 1];\n      if (arr[idx] == null || typeof arr[idx] !== \"object\") {\n        arr[idx] = nextContainerForStep(next);\n      }\n      setValueBySteps(arr[idx], steps, pos + 1, value);\n    }\n  }\n}\n\n// Старый проектор (без маппинга) оставляем как есть\nfunction applyProjectionPath(outNode, srcNode, steps, pos) {\n  if (pos >= steps.length) return;\n\n  const step = steps[pos];\n\n  // array step on current value\n  if (step.key == null) {\n    if (!Array.isArray(srcNode)) return;\n    if (!Array.isArray(outNode)) return;\n\n    const sel = step.sel;\n    if (!sel) return;\n\n    if (sel.kind === \"all\") {\n      for (let i = 0; i < srcNode.length; i++) {\n        const srcEl = srcNode[i];\n\n        if (pos === steps.length - 1) {\n          outNode[i] = srcEl;\n          continue;\n        }\n\n        if (outNode[i] == null || typeof outNode[i] !== \"object\") {\n          outNode[i] = nextContainerForStep(steps[pos + 1]);\n        } else {\n          if (steps[pos + 1].key == null && !Array.isArray(outNode[i])) outNode[i] = [];\n          if (steps[pos + 1].key != null && Array.isArray(outNode[i])) outNode[i] = {};\n        }\n\n        applyProjectionPath(outNode[i], srcEl, steps, pos + 1);\n      }\n      return;\n    }\n\n    if (sel.kind === \"index\") {\n      const i = normalizeIndex(sel.index, srcNode.length);\n      if (i == null) return;\n      const srcEl = srcNode[i];\n\n      if (pos === steps.length - 1) {\n        outNode.push(srcEl);\n        return;\n      }\n\n      const container = nextContainerForStep(steps[pos + 1]);\n      outNode.push(container);\n      applyProjectionPath(container, srcEl, steps, pos + 1);\n      return;\n    }\n\n    return;\n  }\n\n  // property step\n  if (srcNode == null || typeof srcNode !== \"object\") return;\n  if (!Object.prototype.hasOwnProperty.call(srcNode, step.key)) return;\n\n  const srcVal = srcNode[step.key];\n\n  // no selector\n  if (!step.sel) {\n    if (pos === steps.length - 1) {\n      outNode[step.key] = srcVal;\n      return;\n    }\n\n    const next = steps[pos + 1];\n    const wanted = nextContainerForStep(next);\n\n    if (outNode[step.key] == null || typeof outNode[step.key] !== \"object\") {\n      outNode[step.key] = wanted;\n    } else {\n      if (next.key == null && !Array.isArray(outNode[step.key])) outNode[step.key] = [];\n      if (next.key != null && Array.isArray(outNode[step.key])) outNode[step.key] = {};\n    }\n\n    applyProjectionPath(outNode[step.key], srcVal, steps, pos + 1);\n    return;\n  }\n\n  // selector on property\n  if (!Array.isArray(srcVal)) return;\n\n  if (step.sel.kind === \"all\") {\n    if (!Array.isArray(outNode[step.key])) outNode[step.key] = [];\n    const outArr = outNode[step.key];\n\n    for (let i = 0; i < srcVal.length; i++) {\n      const srcEl = srcVal[i];\n\n      if (pos === steps.length - 1) {\n        outArr[i] = srcEl;\n        continue;\n      }\n\n      const next = steps[pos + 1];\n      const wanted = nextContainerForStep(next);\n\n      if (outArr[i] == null || typeof outArr[i] !== \"object\") {\n        outArr[i] = wanted;\n      } else {\n        if (next.key == null && !Array.isArray(outArr[i])) outArr[i] = [];\n        if (next.key != null && Array.isArray(outArr[i])) outArr[i] = {};\n      }\n\n      applyProjectionPath(outArr[i], srcEl, steps, pos + 1);\n    }\n\n    return;\n  }\n\n  if (step.sel.kind === \"index\") {\n    const i = normalizeIndex(step.sel.index, srcVal.length);\n    if (i == null) return;\n\n    if (!Array.isArray(outNode[step.key])) outNode[step.key] = [];\n    const outArr = outNode[step.key];\n    const srcEl = srcVal[i];\n\n    if (pos === steps.length - 1) {\n      outArr.push(srcEl);\n      return;\n    }\n\n    const container = nextContainerForStep(steps[pos + 1]);\n    outArr.push(container);\n    applyProjectionPath(container, srcEl, steps, pos + 1);\n    return;\n  }\n}\n\nfunction projectObjectByKeys(src, onlyKeys) {\n  if (!onlyKeys || !onlyKeys.length) return src;\n\n  if (Array.isArray(src)) {\n    return src.map(el => projectObjectByKeys(el, onlyKeys));\n  }\n\n  if (!isPlainObject(src)) return src;\n\n  const out = {};\n  for (const kRaw of onlyKeys) {\n    const m = splitReturnMapping(kRaw);\n    if (!m) continue;\n\n    const srcPath = String(m.src).trim();\n    if (!srcPath) continue;\n\n    // ✅ обычный режим (как было)\n    if (!m.dst) {\n      const steps = parsePathPattern(srcPath);\n      if (!steps.length) continue;\n      applyProjectionPath(out, src, steps, 0);\n      continue;\n    }\n\n    // ✅ режим \"src:dst\"\n    const dstPath = String(m.dst).trim();\n    if (!dstPath) continue;\n\n    const srcSteps = parsePathPattern(srcPath);\n    const dstSteps = parsePathPattern(dstPath);\n    if (!srcSteps.length || !dstSteps.length) continue;\n\n    const values = collectValuesBySteps(src, srcSteps, 0);\n    if (!values.length) continue;\n\n    const valToSet = values.length === 1 ? values[0] : values;\n    setValueBySteps(out, dstSteps, 0, valToSet);\n  }\n  return out;\n}\n\n// ============================\n// DELETE (keysToDelete) — dot-path + [] + [n]/[-1]/[idx]\n\nfunction deleteBySteps(root, steps, pos) {\n  if (pos >= steps.length) return;\n\n  const step = steps[pos];\n\n  // array step on current\n  if (step.key == null) {\n    if (!Array.isArray(root) || !step.sel) return;\n\n    if (step.sel.kind === \"all\") {\n      for (let i = 0; i < root.length; i++) {\n        if (pos === steps.length - 1) {\n          root.splice(i, 1);\n          i--;\n        } else {\n          deleteBySteps(root[i], steps, pos + 1);\n        }\n      }\n      return;\n    }\n\n    if (step.sel.kind === \"index\") {\n      let idx = step.sel.index;\n      if (!Number.isFinite(idx)) return;\n      if (idx < 0) idx = root.length + idx;\n      if (idx < 0 || idx >= root.length) return;\n\n      if (pos === steps.length - 1) {\n        root.splice(idx, 1);\n      } else {\n        deleteBySteps(root[idx], steps, pos + 1);\n      }\n      return;\n    }\n\n    return;\n  }\n\n  // property step\n  if (root == null || typeof root !== \"object\") return;\n  if (!Object.prototype.hasOwnProperty.call(root, step.key)) return;\n\n  // no selector\n  if (!step.sel) {\n    if (pos === steps.length - 1) {\n      delete root[step.key];\n      return;\n    }\n    deleteBySteps(root[step.key], steps, pos + 1);\n    return;\n  }\n\n  // selector on property\n  const val = root[step.key];\n  if (!Array.isArray(val)) return;\n\n  if (step.sel.kind === \"all\") {\n    if (pos === steps.length - 1) {\n      delete root[step.key];\n      return;\n    }\n    for (let i = 0; i < val.length; i++) {\n      deleteBySteps(val[i], steps, pos + 1);\n    }\n    return;\n  }\n\n  if (step.sel.kind === \"index\") {\n    let idx = step.sel.index;\n    if (!Number.isFinite(idx)) return;\n    if (idx < 0) idx = val.length + idx;\n    if (idx < 0 || idx >= val.length) return;\n\n    if (pos === steps.length - 1) {\n      val.splice(idx, 1);\n      return;\n    }\n    deleteBySteps(val[idx], steps, pos + 1);\n    return;\n  }\n}\n\nfunction deleteKeysByPaths(root, keysToDelete) {\n  if (!keysToDelete || !Array.isArray(keysToDelete) || !keysToDelete.length) return root;\n\n  // если root — массив, применяем ко всем элементам\n  if (Array.isArray(root)) {\n    for (let i = 0; i < root.length; i++) {\n      deleteKeysByPaths(root[i], keysToDelete);\n    }\n    return root;\n  }\n\n  if (!isPlainObject(root)) return root;\n\n  for (const kRaw of keysToDelete) {\n    const k = String(kRaw).trim();\n    if (!k) continue;\n    const steps = parsePathPattern(k);\n    if (!steps.length) continue;\n    deleteBySteps(root, steps, 0);\n  }\n\n  return root;\n}\n\n// ============================\n// PATCH APPLY (dot-path + [] + [n])\n\nfunction ensureArrayContainer(v) {\n  if (Array.isArray(v)) return v;\n  return [];\n}\n\nfunction applyPatchPath(target, steps, pos, value) {\n  if (pos >= steps.length) return;\n\n  const step = steps[pos];\n\n  // array step on current\n  if (step.key == null) {\n    if (!Array.isArray(target)) return;\n    const sel = step.sel;\n    if (!sel) return;\n\n    if (sel.kind === \"all\") {\n      for (let i = 0; i < target.length; i++) {\n        if (pos === steps.length - 1) {\n          target[i] = value;\n          continue;\n        }\n        const next = steps[pos + 1];\n        if (target[i] == null || typeof target[i] !== \"object\") {\n          target[i] = nextContainerForStep(next);\n        }\n        applyPatchPath(target[i], steps, pos + 1, value);\n      }\n      return;\n    }\n\n    if (sel.kind === \"index\") {\n      let idx = sel.index;\n      if (!Number.isFinite(idx)) return;\n\n      if (idx < 0) idx = target.length + idx;\n      if (idx < 0) idx = 0;\n\n      while (target.length <= idx) target.push(undefined);\n\n      if (pos === steps.length - 1) {\n        target[idx] = value;\n        return;\n      }\n\n      const next = steps[pos + 1];\n      if (target[idx] == null || typeof target[idx] !== \"object\") {\n        target[idx] = nextContainerForStep(next);\n      }\n      applyPatchPath(target[idx], steps, pos + 1, value);\n      return;\n    }\n\n    return;\n  }\n\n  // property step\n  if (target == null || typeof target !== \"object\") return;\n\n  if (!step.sel) {\n    if (pos === steps.length - 1) {\n      // ✅ если оба объекта — мерджим, а не перезатираем\n      if (isPlainObject(value) && isPlainObject(target[step.key])) {\n        deepMergeObjectsInPlace(target[step.key], value);\n      } else {\n        target[step.key] = value;\n      }\n      return;\n    }\n\n    const next = steps[pos + 1];\n    const wantsArray = next.key == null;\n\n    if (target[step.key] == null || typeof target[step.key] !== \"object\") {\n      target[step.key] = wantsArray ? [] : {};\n    } else {\n      if (wantsArray && !Array.isArray(target[step.key])) target[step.key] = [];\n      if (!wantsArray && Array.isArray(target[step.key])) target[step.key] = {};\n    }\n\n    applyPatchPath(target[step.key], steps, pos + 1, value);\n    return;\n  }\n\n  target[step.key] = ensureArrayContainer(target[step.key]);\n  const arr = target[step.key];\n\n  if (step.sel.kind === \"all\") {\n    for (let i = 0; i < arr.length; i++) {\n      if (pos === steps.length - 1) {\n        arr[i] = value;\n        continue;\n      }\n      const next = steps[pos + 1];\n      if (arr[i] == null || typeof arr[i] !== \"object\") {\n        arr[i] = nextContainerForStep(next);\n      }\n      applyPatchPath(arr[i], steps, pos + 1, value);\n    }\n    return;\n  }\n\n  if (step.sel.kind === \"index\") {\n    let idx = step.sel.index;\n    if (!Number.isFinite(idx)) return;\n\n    if (idx < 0) idx = arr.length + idx;\n    if (idx < 0) idx = 0;\n\n    while (arr.length <= idx) arr.push(undefined);\n\n    if (pos === steps.length - 1) {\n      arr[idx] = value;\n      return;\n    }\n\n    const next = steps[pos + 1];\n    if (arr[idx] == null || typeof arr[idx] !== \"object\") {\n      arr[idx] = nextContainerForStep(next);\n    }\n    applyPatchPath(arr[idx], steps, pos + 1, value);\n    return;\n  }\n}\n\nfunction applyPatchToAny(root, patch) {\n  if (!patch || typeof patch !== \"object\") return root;\n\n  if (Array.isArray(root)) {\n    for (let i = 0; i < root.length; i++) {\n      if (root[i] && typeof root[i] === \"object\") {\n        applyPatchToAny(root[i], patch);\n      }\n    }\n    return root;\n  }\n\n  if (!isPlainObject(root)) return root;\n\n  for (const [kRaw, v] of Object.entries(patch)) {\n    if (v === undefined) continue;\n    const k = String(kRaw).trim();\n    if (!k) continue;\n\n    const steps = parsePathPattern(k);\n    if (!steps.length) continue;\n\n    applyPatchPath(root, steps, 0, v);\n  }\n\n  return root;\n}\n\n// ============================\n// OTHER HELPERS\n\nfunction buildPatchForItem(item, idx) {\n  const fp = item.json?.filePath;\n  const key = fp != null ? String(fp) : `__idx_${idx}`;\n\n  const merged = MERGED_KEYS_TO_WRITE_BY_FILEPATH.get(key);\n  const patch = isPlainObject(merged)\n    ? cloneJson(merged)\n    : (isPlainObject(PATCH_BASE) ? cloneJson(PATCH_BASE) : {});\n\n  const extraPatch = item.json?.patch ?? $input.first()?.json?.patch;\n  if (isPlainObject(extraPatch)) {\n    for (const [k, v] of Object.entries(extraPatch)) {\n      if (v !== undefined) patch[k] = v;\n    }\n  }\n\n  return patch;\n}\n\nfunction resolveOnlyKeys(item) {\n  const keys =\n    item.json?.onlyKeys ??\n    $input.first()?.json?.onlyKeys ??\n    ONLY_KEYS_FALLBACK;\n\n  if (!Array.isArray(keys)) return null;\n  const cleaned = keys.map(k => String(k).trim()).filter(Boolean);\n  return cleaned.length ? cleaned : null;\n}\n\nfunction resolveKeysToDelete(item) {\n  const keys =\n    item.json?.keysToDelete ??\n    $input.first()?.json?.keysToDelete ??\n    KEYS_TO_DELETE;\n\n  if (!Array.isArray(keys)) return null;\n  const cleaned = keys.map(k => String(k).trim()).filter(Boolean);\n  return cleaned.length ? cleaned : null;\n}\n\nfunction resolveReturnBinary(item) {\n  if (item.json?.returnBinary !== undefined) return Boolean(item.json.returnBinary);\n  const g = $input.first()?.json?.returnBinary;\n  if (g !== undefined) return Boolean(g);\n  return Boolean(RETURN_BINARY_FALLBACK);\n}\n\nfunction resolveReturnJson(item) {\n  if (item.json?.returnJson !== undefined) return Boolean(item.json.returnJson);\n  const g = $input.first()?.json?.returnJson;\n  if (g !== undefined) return Boolean(g);\n  return Boolean(RETURN_JSON_FALLBACK);\n}\n\nfunction resolveReplaceWholeJson(item) {\n  if (item.json?.replaceWholeJson !== undefined) return Boolean(item.json.replaceWholeJson);\n  const g = $input.first()?.json?.replaceWholeJson;\n  if (g !== undefined) return Boolean(g);\n  return Boolean(REPLACE_WHOLE_JSON_FALLBACK);\n}\n\nfunction getReplaceJson(item) {\n  const v = item.json?.replaceJson ?? $input.first()?.json?.replaceJson;\n  return v !== undefined ? v : DEFAULT_REPLACE_JSON;\n}\n\nfunction getSourceItemForIndexSafe(idx) {\n  try {\n    if (!SOURCE_NODE) return items[idx] ?? null;\n\n    try {\n      const m = $(SOURCE_NODE).itemMatching(idx);\n      if (m) return m;\n    } catch (_) {}\n\n    try {\n      const all = $(SOURCE_NODE).all();\n      return all?.[idx] ?? null;\n    } catch (_) {}\n\n    return null;\n  } catch (_) {\n    return null;\n  }\n}\n\nfunction pickBinKeySafe(srcItem) {\n  try {\n    if (SOURCE_BIN_KEY) return SOURCE_BIN_KEY;\n    const keys = Object.keys(srcItem?.binary || {});\n    return keys[0] || \"\";\n  } catch (_) {\n    return \"\";\n  }\n}\n\nfunction hasBinaryPayload(srcItem, binKey) {\n  try {\n    if (!srcItem?.binary?.[binKey]) return false;\n    const b = srcItem.binary[binKey];\n    if (typeof b.data === \"string\" && b.data.length > 0) return true;\n    return false;\n  } catch (_) {\n    return false;\n  }\n}\n\nfunction shouldWriteEmptyFile(jsonObj) {\n  if (!jsonObj) return true;\n  if (isPlainObject(jsonObj)) return Object.keys(jsonObj).length === 0;\n  if (Array.isArray(jsonObj)) return jsonObj.length === 0;\n  return false;\n}\n\nfunction applyReturnJsonFlag(result, shouldReturnJson) {\n  if (!shouldReturnJson) result.json = {};\n  return result;\n}\n\nfunction makeFallbackJson(item, idx) {\n  const json = {};\n  const patch = buildPatchForItem(item, idx);\n  applyPatchToAny(json, patch);\n\n  const keysToDelete = resolveKeysToDelete(item);\n  deleteKeysByPaths(json, keysToDelete);\n\n  const onlyKeys = resolveOnlyKeys(item);\n  return projectObjectByKeys(json, onlyKeys);\n}\n\n// ============================\n// MAIN\n\nreturn await Promise.all(\n  items.map(async (item, idx) => {\n    const shouldReturnBinary = resolveReturnBinary(item);\n    const shouldReturnJson = resolveReturnJson(item);\n    const shouldReplaceWholeJson = resolveReplaceWholeJson(item);\n\n    // ====== РЕЖИМ ПОЛНОЙ ЗАМЕНЫ JSON ======\n    if (shouldReplaceWholeJson) {\n      let json = getReplaceJson(item);\n      if (!isPlainObject(json) && !Array.isArray(json)) json = {};\n\n      const keysToDelete = resolveKeysToDelete(item);\n      deleteKeysByPaths(json, keysToDelete);\n\n      const onlyKeys = resolveOnlyKeys(item);\n      json = projectObjectByKeys(json, onlyKeys);\n\n      const result = { json, pairedItem: idx };\n\n      if (shouldReturnBinary) {\n        const fileName =\n          (item.json?.fileName && String(item.json.fileName).trim()) ||\n          DEFAULT_OUT_FILE;\n\n        const outText = shouldWriteEmptyFile(json) ? \"\" : (JSON.stringify(json, null, 2) + \"\\n\");\n        const outBuf = Buffer.from(outText, \"utf8\");\n\n        const binaryData = await this.helpers.prepareBinaryData(\n          outBuf,\n          fileName,\n          \"application/json\"\n        );\n\n        result.binary = { data: binaryData };\n      }\n\n      return applyReturnJsonFlag(result, shouldReturnJson);\n    }\n\n    // ====== ОБЫЧНЫЙ РЕЖИМ ======\n\n    const srcItem = getSourceItemForIndexSafe(idx);\n    const binKey = pickBinKeySafe(srcItem);\n\n    if (!srcItem || !binKey || !hasBinaryPayload(srcItem, binKey)) {\n      const json = makeFallbackJson(item, idx);\n\n      const result = { json, pairedItem: idx };\n\n      if (shouldReturnBinary) {\n        const fileName =\n          (item.json?.fileName && String(item.json.fileName).trim()) ||\n          srcItem?.binary?.[binKey]?.fileName ||\n          DEFAULT_OUT_FILE;\n\n        const outText = shouldWriteEmptyFile(json) ? \"\" : (JSON.stringify(json, null, 2) + \"\\n\");\n        const outBuf = Buffer.from(outText, \"utf8\");\n\n        const binaryData = await this.helpers.prepareBinaryData(\n          outBuf,\n          fileName,\n          \"application/json\"\n        );\n\n        result.binary = { data: binaryData };\n      }\n\n      return applyReturnJsonFlag(result, shouldReturnJson);\n    }\n\n    try {\n      if (SOURCE_NODE) {\n        item.binary = item.binary || {};\n        item.binary[binKey] = srcItem.binary[binKey];\n      }\n    } catch (_) {}\n\n    let text = \"\";\n    try {\n      const buf = await this.helpers.getBinaryDataBuffer(idx, binKey);\n      if (buf && buf.length) text = buf.toString(\"utf8\");\n    } catch (_) {}\n\n    if (!text || !String(text).trim()) {\n      const json = makeFallbackJson(item, idx);\n\n      const result = { json, pairedItem: idx };\n\n      if (shouldReturnBinary) {\n        const fileName =\n          (item.json?.fileName && String(item.json.fileName).trim()) ||\n          srcItem.binary?.[binKey]?.fileName ||\n          DEFAULT_OUT_FILE;\n\n        const outText = shouldWriteEmptyFile(json) ? \"\" : (JSON.stringify(json, null, 2) + \"\\n\");\n        const outBuf = Buffer.from(outText, \"utf8\");\n\n        const binaryData = await this.helpers.prepareBinaryData(\n          outBuf,\n          fileName,\n          \"application/json\"\n        );\n\n        result.binary = { data: binaryData };\n      }\n\n      return applyReturnJsonFlag(result, shouldReturnJson);\n    }\n\n    let json;\n    try {\n      json = parseJsonLenient(text, idx);\n      if (!isPlainObject(json) && !Array.isArray(json)) json = {};\n    } catch (_) {\n      json = {};\n    }\n\n    const patch = buildPatchForItem(item, idx);\n\n    if (isPlainObject(json) || Array.isArray(json)) {\n      applyPatchToAny(json, patch);\n    } else {\n      json = makeFallbackJson(item, idx);\n    }\n\n    const keysToDelete = resolveKeysToDelete(item);\n    deleteKeysByPaths(json, keysToDelete);\n\n    const onlyKeys = resolveOnlyKeys(item);\n    json = projectObjectByKeys(json, onlyKeys);\n\n    const result = { json, pairedItem: idx };\n\n    if (shouldReturnBinary) {\n      const fileName =\n        (item.json?.fileName && String(item.json.fileName).trim()) ||\n        srcItem.binary?.[binKey]?.fileName ||\n        DEFAULT_OUT_FILE;\n\n      const outText = shouldWriteEmptyFile(json) ? \"\" : (JSON.stringify(json, null, 2) + \"\\n\");\n      const outBuf = Buffer.from(outText, \"utf8\");\n\n      const binaryData = await this.helpers.prepareBinaryData(\n        outBuf,\n        fileName,\n        \"application/json\"\n      );\n\n      result.binary = { data: binaryData };\n    }\n\n    return applyReturnJsonFlag(result, shouldReturnJson);\n  })\n);"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        800,
        -304
      ],
      "id": "1ea1dec8-d2fe-4fbf-a90d-5acae22c89af",
      "name": "Return Json Keys1"
    }
  ],
  "connections": {
    "Start": {
      "main": [
        [
          {
            "node": "Read JSON File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read JSON File": {
      "main": [
        [
          {
            "node": "Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch": {
      "main": [
        [
          {
            "node": "Return Json Keys",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Return Binary With New Fields",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Delete File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Return Binary With New Fields": {
      "main": [
        [
          {
            "node": "Write JSON File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write JSON File": {
      "main": [
        [
          {
            "node": "Switch1",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "Switch1": {
      "main": [
        [
          {
            "node": "empty out",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Create File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create File": {
      "main": [
        [
          {
            "node": "Read JSON File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete File": {
      "main": [
        [
          {
            "node": "empty out",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": null,
  "pinData": {
    "Start": [
      {
        "json": {
          "filePath": "C:/Users/V/Desktop/Channels/WgladWPrzeszlosc/VIDEOS/2026-02-08_VySCN/VOICE/transcript/2026-02-08_VySCN_transcript.json",
          "fileAction": "read",
          "keysToReturn": [
            "items[n].text",
            "items[n].start_ms",
            "items[n].end_ms"
          ],
          "keysToWrite": {},
          "keysToDelete": []
        },
        "pairedItem": {
          "item": 0
        }
      }
    ]
  },
  "versionId": "528fe072-9ca5-491b-953e-0c8c9c52c1bc",
  "activeVersionId": "528fe072-9ca5-491b-953e-0c8c9c52c1bc",
  "versionCounter": 352,
  "triggerCount": 0,
  "tags": [],
  "shared": [
    {
      "updatedAt": "2026-02-03T20:31:14.885Z",
      "createdAt": "2026-02-03T20:31:14.885Z",
      "role": "workflow:owner",
      "workflowId": "qwG1pltFOQqqJLyh",
      "projectId": "jyxvHYm2zz0wpNIZ",
      "project": {
        "updatedAt": "2026-02-03T20:00:07.843Z",
        "createdAt": "2026-02-03T19:58:35.642Z",
        "id": "jyxvHYm2zz0wpNIZ",
        "name": "Vladislav Kostromin <bad4rr@gmail.com>",
        "type": "personal",
        "icon": null,
        "description": null,
        "creatorId": "791bcae9-1f6e-48f2-9f28-d86a2c32ea27"
      }
    }
  ]
}