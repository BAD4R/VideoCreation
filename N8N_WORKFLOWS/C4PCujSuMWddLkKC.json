{
  "updatedAt": "2026-02-16T17:00:21.587Z",
  "createdAt": "2026-02-05T01:25:42.639Z",
  "id": "C4PCujSuMWddLkKC",
  "name": "generate clips prompts",
  "description": null,
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "inputSource": "jsonExample",
        "jsonExample": "{\n  \"channelsFolderPath\": \"\",\n  \"channelName\": \"\",\n  \"videoFolderName\": \"\"\n}"
      },
      "id": "c055762a-8fe7-4141-a639-df2372f30060",
      "typeVersion": 1.1,
      "name": "Start",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "position": [
        80,
        352
      ]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "leftValue": "={{ $('get text gen service and eachVisualScreenTime').first().json.textGenService == \"gemini\" }}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "id": "5ee75887-7518-4802-9c6e-47f913300963"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "gemini"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "c4c3ce37-169a-4d45-bf04-1fbf84efb151",
                    "leftValue": "={{ $('get text gen service and eachVisualScreenTime').first().json.textGenService == \"openai\" }}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "openai"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "05f5648d-1a6e-4f8d-97aa-2f4f035e56c5",
                    "leftValue": "={{ $('get text gen service and eachVisualScreenTime').first().json.textGenService == \"runpod\" }}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "runpod"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.4,
      "position": [
        1040,
        336
      ],
      "id": "f04beca3-37e8-4adb-91bf-1aacbc78e183",
      "name": "Switch Text Gen Service"
    },
    {
      "parameters": {
        "fieldToSplitOut": "parts",
        "options": {}
      },
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        1744,
        240
      ],
      "id": "1536454c-c9a1-4245-9904-48c4bffebc85",
      "name": "Split Out"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "dfdd0d91-ac5d-4128-9ffa-95d35e0ba6a6",
              "leftValue": "={{(()=>{\nlet existingClipPromptIndexes = []\n\nif ($('get ready clips prompts').item.json.existingFilesNames.length > 0){\n  existingClipPromptIndexes = $('get ready clips prompts').first().json.existingFilesNames.map(name=>name.slice(-9,-4).toInt())\n}\n\nconst partIndex = $json.partIndex\n\nreturn !existingClipPromptIndexes.includes(partIndex)\n})()}}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.filter",
      "typeVersion": 2.3,
      "position": [
        1936,
        240
      ],
      "id": "04f73a7c-fd3a-46a8-97bd-d98c50bb8335",
      "name": "Filter"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "e75bcbea-1374-432d-a6cd-6b9f2cc42c78",
              "leftValue": "={{ $('check if clips prompts ready').last().json.filesReady }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        1936,
        400
      ],
      "id": "f1f10aaf-bbeb-41c8-bde4-fdae24790d9c",
      "name": "If Audio Ready"
    },
    {
      "parameters": {
        "amount": 15
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        2032,
        496
      ],
      "id": "b2eaec50-d048-4712-92d9-13f73fa3b34a",
      "name": "Wait",
      "webhookId": "acf3fd65-1471-4d76-af5f-1c5dd091db93"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.limit",
      "typeVersion": 1,
      "position": [
        2144,
        400
      ],
      "id": "edda7806-d17f-4b68-8bee-2f3503d28695",
      "name": "Limit1"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "N2bXusYBgofvRBlH",
          "mode": "list",
          "cachedResultUrl": "/workflow/N2bXusYBgofvRBlH",
          "cachedResultName": "check files quantity in directory"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "directoryPath": "={{ $('Start').first().json.channelsFolderPath }}/{{ $('Start').first().json.channelName }}/VIDEOS/{{ $('Start').first().json.videoFolderName }}/CLIPS/videoClipPrompts",
            "fileExtentionToSearch": ".txt",
            "expectedFilesCount": "={{ $('Define Visuals Duration(normalized) and Text Part').first().json.parts.length }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "directoryPath",
              "displayName": "directoryPath",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "fileExtentionToSearch",
              "displayName": "fileExtentionToSearch",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "fileNameToSearch",
              "displayName": "fileNameToSearch",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "expectedFilesCount",
              "displayName": "expectedFilesCount",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        1744,
        400
      ],
      "id": "4f1a8a6c-b628-4aa7-91b2-83c1304893f8",
      "name": "check if clips prompts ready"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "qwG1pltFOQqqJLyh",
          "mode": "list",
          "cachedResultUrl": "/workflow/qwG1pltFOQqqJLyh",
          "cachedResultName": "JSON File Works"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "filePath": "={{ $('Start').first().json.channelsFolderPath }}/{{ $('Start').first().json.channelName }}/VIDEOS/{{ $('Start').first().json.videoFolderName }}/videoStatus.json",
            "fileAction": "write",
            "keysToReturn": "={{ [] }}",
            "keysToWrite": "={{ {\n\"clipsPromptsReady\":true\n} }}",
            "keysToDelete": "={{ [] }}"
          },
          "matchingColumns": [
            "channelsFolderPath_firstItem",
            "channelName_firstItem"
          ],
          "schema": [
            {
              "id": "filePath",
              "displayName": "filePath",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "fileAction",
              "displayName": "fileAction",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "keysToReturn",
              "displayName": "keysToReturn",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "array",
              "removed": false
            },
            {
              "id": "keysToWrite",
              "displayName": "keysToWrite",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "object",
              "removed": false
            },
            {
              "id": "keysToDelete",
              "displayName": "keysToDelete",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "array",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        2384,
        400
      ],
      "name": "set clips prompts ready",
      "id": "a194b8b3-e44b-47e3-a031-17ff1a607ba4"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "qwG1pltFOQqqJLyh",
          "mode": "list",
          "cachedResultUrl": "/workflow/qwG1pltFOQqqJLyh",
          "cachedResultName": "JSON File Works"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "filePath": "={{ $('Start').first().json.channelsFolderPath }}/{{ $('Start').first().json.channelName }}/settings.json",
            "fileAction": "read",
            "keysToReturn": "={{ [\"textGenService\", \"eachVisualMinScreenTimeMs\", \"eachVisualMaxScreenTimeMs\"] }}",
            "keysToWrite": "={{ {} }}",
            "keysToDelete": "={{ [] }}"
          },
          "matchingColumns": [
            "channelsFolderPath_firstItem",
            "channelName_firstItem"
          ],
          "schema": [
            {
              "id": "filePath",
              "displayName": "filePath",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "fileAction",
              "displayName": "fileAction",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "keysToReturn",
              "displayName": "keysToReturn",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "array",
              "removed": false
            },
            {
              "id": "keysToWrite",
              "displayName": "keysToWrite",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "object",
              "removed": false
            },
            {
              "id": "keysToDelete",
              "displayName": "keysToDelete",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "array",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        320,
        352
      ],
      "name": "get text gen service and eachVisualScreenTime",
      "id": "1ac9e22c-7827-408f-bd32-4d39da6a13db"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "qwG1pltFOQqqJLyh",
          "mode": "list",
          "cachedResultUrl": "/workflow/qwG1pltFOQqqJLyh",
          "cachedResultName": "JSON File Works"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "filePath": "={{ $('Start').first().json.channelsFolderPath }}/{{ $('Start').first().json.channelName }}/VIDEOS/{{ $('Start').first().json.videoFolderName }}/VOICE/transcript/{{ $('Start').first().json.videoFolderName }}_transcript.json",
            "fileAction": "read",
            "keysToReturn": "={{ [\"items[n].text\",\"items[n].start_ms\",\"items[n].end_ms\"] }}",
            "keysToWrite": "={{ {} }}",
            "keysToDelete": "={{ [] }}"
          },
          "matchingColumns": [
            "channelsFolderPath_firstItem",
            "channelName_firstItem"
          ],
          "schema": [
            {
              "id": "filePath",
              "displayName": "filePath",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "fileAction",
              "displayName": "fileAction",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "keysToReturn",
              "displayName": "keysToReturn",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "array",
              "removed": false
            },
            {
              "id": "keysToWrite",
              "displayName": "keysToWrite",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "object",
              "removed": false
            },
            {
              "id": "keysToDelete",
              "displayName": "keysToDelete",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "array",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        528,
        352
      ],
      "name": "get start/end ms of each scentance from transcript",
      "id": "2bdf4d2e-170d-4fb0-a85e-cd3b1d2b2330"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "N2bXusYBgofvRBlH",
          "mode": "list",
          "cachedResultUrl": "/workflow/N2bXusYBgofvRBlH",
          "cachedResultName": "check files quantity in directory"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "directoryPath": "={{ $('Start').first().json.channelsFolderPath }}/{{ $('Start').first().json.channelName }}/VIDEOS/{{ $('Start').first().json.videoFolderName }}/CLIPS/videoClipPrompts",
            "fileExtentionToSearch": ".txt",
            "expectedFilesCount": -1
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "directoryPath",
              "displayName": "directoryPath",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "fileExtentionToSearch",
              "displayName": "fileExtentionToSearch",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "fileNameToSearch",
              "displayName": "fileNameToSearch",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "expectedFilesCount",
              "displayName": "expectedFilesCount",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        1344,
        240
      ],
      "id": "d38e8439-17ff-46ed-9192-5fcd9fd48d64",
      "name": "get ready clips prompts"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "laRC9gkCLuLdoDub",
          "mode": "list",
          "cachedResultUrl": "/workflow/laRC9gkCLuLdoDub",
          "cachedResultName": "generate clips prompts in gemini - paralleling"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "channelsFolderPath": "={{ $('Start').first().json.channelsFolderPath }}",
            "channelName": "={{ $('Start').first().json.channelName }}",
            "videoFolderName": "={{ $('Start').first().json.videoFolderName }}",
            "previousTextPart": "={{ $json.partIndex > 0 ? $('Define Visuals Duration(normalized) and Text Part').first().json.parts[$json.partIndex-1].text : '[No previous text part! This is a first request.]' }}",
            "currentTextPart": "={{ $json.text }}",
            "nextTextPart": "={{ $json.partIndex < $('Define Visuals Duration(normalized) and Text Part').first().json.parts.length-1 ? $('Define Visuals Duration(normalized) and Text Part').first().json.parts[$json.partIndex+1].text : '[No next text part! This is a last request.]'  }}",
            "textPartIndex": "={{ $json.partIndex }}",
            "partDurationMs": "={{ $json.meta.durMs }}"
          },
          "matchingColumns": [
            "textToVideoPromptGenerationPrompt_firstItem",
            "textToVideoBase_firstItem",
            "textGenModel_firstItem",
            "meta_durMs",
            "text",
            "geminiAiResponsesRoute_firstItem",
            "proxyServerPort_firstItem",
            "proxyServerIP_firstItem",
            "googleApiKey_firstItem",
            "parts_length",
            "parts",
            "videoDescription_join_firstItem",
            "videoTitle_join_firstItem",
            "partIndex"
          ],
          "schema": [
            {
              "id": "channelsFolderPath",
              "displayName": "channelsFolderPath",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "channelName",
              "displayName": "channelName",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "videoFolderName",
              "displayName": "videoFolderName",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "previousTextPart",
              "displayName": "previousTextPart",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "currentTextPart",
              "displayName": "currentTextPart",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "nextTextPart",
              "displayName": "nextTextPart",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "partDurationMs",
              "displayName": "partDurationMs",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "textPartIndex",
              "displayName": "textPartIndex",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "mode": "each",
        "options": {
          "waitForSubWorkflow": false
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        2384,
        240
      ],
      "name": "generate clips prompts im gemini - paralleling",
      "id": "fa07d9a1-209a-43b7-b246-6e74ba90b6b2"
    },
    {
      "parameters": {
        "jsCode": "// ===============================\n// ‚úÖ INPUT VARIABLES (—á—Ç–æ –ø–æ–¥–∞—Ç—å –Ω–∞ –≤—Ö–æ–¥)\n// ===============================\n\n// 1) –°–ï–ì–ú–ï–ù–¢–´ –¢–†–ê–ù–°–ö–†–ò–ü–¢–ê (–º–∞—Å—Å–∏–≤ –æ–±—ä–µ–∫—Ç–æ–≤)\nconst RAW_SEGMENTS = $('get start/end ms of each scentance from transcript').first().json.items;\n\n// 2) MIN / MAX —ç–∫—Ä–∞–Ω–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ (–º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥—ã)\nconst EACH_IMAGE_MIN_SCREEN_TIME_MS = $('get text gen service and eachVisualScreenTime').first().json.eachVisualMinScreenTimeMs;\nconst EACH_IMAGE_MAX_SCREEN_TIME_MS = $('get text gen service and eachVisualScreenTime').first().json.eachVisualMaxScreenTimeMs;\n\n// 3) ‚Äú–ú—è–≥–∫–∏–π –ø–µ—Ä–µ–ª—ë—Ç‚Äù ‚Äî –ó–ê–ü–†–ï–©–ï–ù (—Å—Ç—Ä–æ–≥–æ –Ω–µ –≤—ã—Ö–æ–¥–∏–º –∑–∞ max)\nconst SOFT_OVERFLOW_MS = 0;\n\n// 4) –ö–∞–∫–∏–µ –∫–ª—é—á–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤ RAW_SEGMENTS\nconst TEXT_KEY   = 'text';\nconst START_KEYS = ['start_ms', 'start'];\nconst END_KEYS   = ['end_ms', 'end'];\n\n// 5) –ï–¥–∏–Ω–∏—Ü—ã –≤—Ä–µ–º–µ–Ω–∏\nconst TIME_UNIT = 'auto'; // 'auto' | 'ms' | 's'\n\n// 6) –û–±—â–∞—è –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Ç—Ä–µ–∫–∞ (–≤ –º—Å). –ï—Å–ª–∏ –Ω–µ –Ω–∞–π–¥—ë–º ‚Äî –≤–æ–∑—å–º—ë–º max(end_ms) –ø–æ—Å–ª–µ –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏–∏.\nconst TOTAL_DUR_MS = (() => {\n  try {\n    const j = $('get start/end ms of each scentance from transcript').first().json;\n\n    const candidates = [\n      j.total_dur_ms,\n      j.totalDurMs,\n      j.total_duration_ms,\n      (Number(j.total_duration_sec) * 1000),\n      (Number(j.meta?.progress?.total_duration_sec) * 1000),\n      (Number(j.meta?.total_duration_sec) * 1000),\n    ];\n\n    for (const c of candidates) {\n      const n = Number(c);\n      if (Number.isFinite(n) && n > 0) return Math.round(n);\n    }\n  } catch (_) {}\n\n  return null;\n})();\n\n\n// ===============================\n// üîß Implementation\n// ===============================\n\nfunction cleanText(s) {\n  return String(s ?? \"\")\n    .replace(/\\r?\\n/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n}\n\nfunction pickFirst(obj, keys) {\n  for (const k of keys) {\n    if (obj && obj[k] != null) return obj[k];\n  }\n  return null;\n}\n\nfunction toNumber(x) {\n  const n = typeof x === \"number\" ? x : parseFloat(String(x));\n  return Number.isFinite(n) ? n : null;\n}\n\n// –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è start/end –≤ –ú–° (–∞ –Ω–µ —Ç–æ–ª—å–∫–æ durMs)\nfunction normalizeStartEndMs(rawSeg) {\n  // 1) start_ms/end_ms -> —Å—á–∏—Ç–∞–µ–º —á—Ç–æ —ç—Ç–æ ms\n  const sMs = toNumber(rawSeg?.start_ms);\n  const eMs = toNumber(rawSeg?.end_ms);\n  if (sMs != null && eMs != null) {\n    const start = Math.max(0, Math.round(sMs));\n    const end = Math.max(start, Math.round(eMs));\n    return { startMs: start, endMs: end };\n  }\n\n  // 2) start/end -> auto/ms/s\n  const s = toNumber(rawSeg?.start);\n  const e = toNumber(rawSeg?.end);\n  if (s == null || e == null) return { startMs: 0, endMs: 0 };\n\n  let factor = 1;\n  if (TIME_UNIT === 's') factor = 1000;\n  else if (TIME_UNIT === 'ms') factor = 1;\n  else {\n    const diff = e - s;\n    const looksLikeSeconds = diff > 0 && diff <= 120 && e <= 20000;\n    factor = looksLikeSeconds ? 1000 : 1;\n  }\n\n  const start = Math.max(0, Math.round(s * factor));\n  const end = Math.max(start, Math.round(e * factor));\n  return { startMs: start, endMs: end };\n}\n\n// ===============================\n// ‚úÖ GAP FILL LOGIC\n// ===============================\nfunction fillGapsInPlace(segs, totalDurMs) {\n  if (!Array.isArray(segs) || segs.length === 0) return { totalDurMs: totalDurMs ?? 0 };\n\n  segs.sort((a, b) => (a.startMs - b.startMs) || (a._origIndex - b._origIndex));\n\n  if (segs[0].startMs > 0) segs[0].startMs = 0;\n  if (segs[0].startMs < 0) segs[0].startMs = 0;\n  if (segs[0].endMs < segs[0].startMs) segs[0].endMs = segs[0].startMs;\n\n  if (!Number.isFinite(totalDurMs) || totalDurMs == null || totalDurMs <= 0) {\n    let mx = 0;\n    for (const s of segs) mx = Math.max(mx, s.endMs);\n    totalDurMs = mx;\n  } else {\n    totalDurMs = Math.max(0, Math.round(totalDurMs));\n  }\n\n  for (let i = 0; i < segs.length - 1; i++) {\n    const cur = segs[i];\n    const next = segs[i + 1];\n\n    if (cur.startMs < 0) cur.startMs = 0;\n    if (next.startMs < 0) next.startMs = 0;\n\n    if (cur.endMs < cur.startMs) cur.endMs = cur.startMs;\n    if (next.endMs < next.startMs) next.endMs = next.startMs;\n\n    let desiredEnd = next.startMs - 1;\n    if (desiredEnd < cur.startMs) desiredEnd = cur.startMs;\n    cur.endMs = desiredEnd;\n\n    if (cur.endMs < cur.startMs) cur.endMs = cur.startMs;\n  }\n\n  const last = segs[segs.length - 1];\n  if (last.startMs < 0) last.startMs = 0;\n  if (last.endMs < last.startMs) last.endMs = last.startMs;\n\n  if (last.endMs < totalDurMs) last.endMs = totalDurMs;\n  if (last.endMs < last.startMs) last.endMs = last.startMs;\n\n  return { totalDurMs };\n}\n\n// --- –≥—Ä–∞–Ω–∏—Ü—ã –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π ---\nconst END_CHARS = new Set([\".\", \"!\", \"?\", \"‚Ä¶\", \"„ÄÇ\", \"ÔºÅ\", \"Ôºü\"]);\nconst CLOSERS = new Set(['\"', \"‚Äù\", \"‚Äô\", \"'\", \")\", \"]\", \"}\", \"¬ª\", \"‚Ä∫\", \"Ôºâ\", \"„Äë\", \"„Äè\", \"„Äç\"]);\n\nconst ABBREV = new Set([\n  // EN\n  \"mr\",\"mrs\",\"ms\",\"mx\",\"dr\",\"prof\",\"sr\",\"jr\",\"st\",\"mt\",\"ft\",\"vs\",\n  \"etc\",\"eg\",\"ie\",\"fig\",\"eq\",\"ref\",\"refs\",\"no\",\"nos\",\"dept\",\"inc\",\"ltd\",\"corp\",\"co\",\"bros\",\n  \"est\",\"misc\",\"approx\",\"appt\",\"avg\",\"min\",\"max\",\"temp\",\"vol\",\"ch\",\"sec\",\"pp\",\"p\",\n  \"jan\",\"feb\",\"mar\",\"apr\",\"may\",\"jun\",\"jul\",\"aug\",\"sep\",\"sept\",\"oct\",\"nov\",\"dec\",\n  \"am\",\"pm\",\"a.m\",\"p.m\",\"u.s\",\"u.k\",\"e.u\",\"u.n\",\n\n  // RU\n  \"–≥\",\"–≥–≥\",\"—É–ª\",\"–¥\",\"–∫–≤\",\"—Å—Ç—Ä\",\"—Ä–∏—Å\",\"–ø—Ä\",\"–ø—Ä–æ—Å–ø\",\"–Ω–∞–±\",\"–±—É–ª\",\"–ø–µ—Ä\",\"–ø–ª\",\"–ø–æ—Å\",\"–æ–±–ª\",\"—Ä-–Ω\",\n  \"–∏–º\",\"–∞–∫–∞–¥\",\"–¥–æ—Ü\",\"–ø—Ä–æ—Ñ\",\"—Å–º\",\"—Ç.–¥\",\"—Ç.–ø\",\"–∏ —Ç.–¥\",\"–∏ —Ç.–ø\",\"–¥—Ä\",\n  \"–º–∏–Ω\",\"—Å–µ–∫\",\"—á\",\"–º–µ—Å\",\"–≥–ª\",\"—Å—Ç\",\"–ø–ø\",\"–ø\",\"–º–ª–Ω\",\"–º–ª—Ä–¥\",\"—Ç—ã—Å\",\"—Ä—É–±\",\"–∫–æ–ø\",\n\n  // PL\n  \"np\",\"itp\",\"itd\",\"m.in\",\"tzn\",\"tj\",\"wg\",\"ok\",\"nr\",\"ul\",\"al\",\"pl\",\"r\",\n  \"godz\",\"min\",\"sek\",\"str\",\"rys\",\"tab\",\"rozdz\",\"pkt\",\"ppkt\",\n  \"dr\",\"hab\",\"mgr\",\"inz\",\"prof\",\n\n  // CZ\n  \"nap≈ô\",\"napr\",\"tzv\",\"atd\",\"apod\",\"tj\",\"tzn\",\"cl\",\"odst\",\"str\",\"obr\",\"tab\",\"kap\",\n  \"ing\",\"mgr\",\"mudr\",\"judr\",\"phdr\",\"bc\",\"dis\",\n\n  // SP (ES)\n  \"sr\",\"sra\",\"srta\",\"dr\",\"dra\",\"ud\",\"uds\",\"pag\",\"pags\",\"num\",\"nro\",\n  \"aprox\",\"etc\",\"av\",\"pto\",\"dpto\",\"art\",\"cap\",\"eeuu\",\n\n  // IT\n  \"sig\",\"sigg\",\"sigra\",\"sigre\",\"dr\",\"dott\",\"dssa\",\"ing\",\"avv\",\"prof\",\n  \"pag\",\"pagg\",\"num\",\"art\",\"cap\",\"ecc\",\"ca\",\"circa\",\"vle\",\"pza\",\"pzza\",\"cso\",\n\n  // FR\n  \"m\",\"mm\",\"mme\",\"mlle\",\"mlles\",\"dr\",\"pr\",\"etc\",\"env\",\"av\",\"bd\",\"st\",\"ste\",\n  \"no\",\"num\",\"art\",\"chap\",\"pag\",\"tel\",\"tva\",\n\n  // GE (DE)\n  \"hr\",\"fr\",\"dr\",\"prof\",\"bzw\",\"z.b\",\"zb\",\"bsp\",\"bspw\",\"usw\",\"vgl\",\"ca\",\n  \"d.h\",\"dh\",\"u.a\",\"ua\",\"u.√§\",\"ue\",\"str\",\"nr\",\"s\",\"abb\",\"ggf\",\"dipl\",\"ing\",\"dipl-ing\",\n\n  // SW\n  \"bl.a\",\"bla\",\"t.ex\",\"tex\",\"dvs\",\"m.fl\",\"mfl\",\"m.m\",\"mm\",\"osv\",\n  \"ca\",\"nr\",\"sid\",\"kap\",\"fig\",\"kl\",\"dr\",\"prof\",\"ing\",\"fru\",\"herr\",\n\n  // HE\n  \"◊ì◊®\",\"◊§◊®◊ï◊§\",\"◊í◊ë\",\"◊û◊®\",\"◊û◊°\",\"◊¢◊û\",\"◊ï◊õ◊ï\",\"◊ú◊ì◊ï◊í\",\"◊®◊ó\",\"◊ò◊ú\",\"◊°◊¢\",\"◊§◊®◊ß\"\n]);\n\n\nfunction isLetterOrDigit(ch) {\n  return /[0-9A-Za-z√Ä-√ñ√ò-√∂√∏-√ø–ê-–Ø–∞-—è–Å—ë]/.test(ch);\n}\n\nfunction isAbbrevDot(text, dotPos) {\n  let i = dotPos - 1;\n  while (i >= 0 && text[i] === \" \") i--;\n\n  const end = i + 1;\n  while (i >= 0 && (isLetterOrDigit(text[i]) || text[i] === \"-\" )) i--;\n  const start = i + 1;\n\n  const word = text.slice(start, end).toLowerCase();\n  if (!word) return false;\n  if (word.length === 1) return true;\n  if (ABBREV.has(word)) return true;\n\n  const lookback = text.slice(Math.max(0, start - 4), dotPos + 1).toLowerCase();\n  if (lookback.includes(\".\") && lookback.length <= 6) return true;\n  return false;\n}\n\nfunction findSentenceBoundaries(text) {\n  const out = [];\n  const n = text.length;\n\n  for (let i = 0; i < n; i++) {\n    const ch = text[i];\n    if (!END_CHARS.has(ch)) continue;\n\n    let j = i;\n    while (j + 1 < n && END_CHARS.has(text[j + 1])) j++;\n\n    if (text[j] === \".\" && isAbbrevDot(text, j)) {\n      i = j;\n      continue;\n    }\n\n    let k = j + 1;\n    while (k < n && CLOSERS.has(text[k])) k++;\n\n    if (k === n || /\\s/.test(text[k])) out.push(k);\n    i = j;\n  }\n  return out;\n}\n\nfunction lastWhitespaceBefore(text, idx) {\n  for (let i = Math.min(idx, text.length - 1); i >= 0; i--) {\n    if (/\\s/.test(text[i])) return i;\n  }\n  return -1;\n}\n\nfunction firstWhitespaceAfter(text, idx) {\n  for (let i = Math.max(0, idx); i < text.length; i++) {\n    if (/\\s/.test(text[i])) return i;\n  }\n  return -1;\n}\n\n// ===============================\n// ‚úÖ STRICT MIN/MAX REBALANCE PATCH\n// ===============================\n\nfunction splitDurStrict(totalDur, minMs, maxMs) {\n  const total = Math.max(0, Math.round(totalDur));\n  if (total === 0) return [];\n  if (total >= minMs && total <= maxMs) return [total];\n\n  // –ú–æ–∂–Ω–æ –ª–∏ —Å–¥–µ–ª–∞—Ç—å –≤—Å–µ —á–∞—Å—Ç–∏ –≤ [min..max]\n  const nMin = Math.ceil(total / maxMs);\n  const nMax = Math.floor(total / minMs);\n\n  if (nMin <= nMax && nMin > 0) {\n    const n = nMin;\n    const base = Math.floor(total / n);\n    let rem = total - base * n;\n    const out = Array(n).fill(base);\n    for (let i = 0; i < n && rem > 0; i++, rem--) out[i]++;\n    return out;\n  }\n\n  // –ò–Ω–∞—á–µ —Å—Ç—Ä–æ–≥–æ –≤—ã–ø–æ–ª–Ω–∏—Ç—å –¥–∏–∞–ø–∞–∑–æ–Ω –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ ‚Äî —Ä–µ–∂–µ–º –ø–æ max, —Ö–≤–æ—Å—Ç –æ—Å—Ç–∞–≤–ª—è–µ–º\n  const out = [];\n  let rem = total;\n  while (rem > maxMs) {\n    out.push(maxMs);\n    rem -= maxMs;\n  }\n  if (rem > 0) out.push(rem);\n  return out;\n}\n\nfunction nearestBoundary(boundaries, minPos, maxPos, idealPos) {\n  let best = -1;\n  let bestDist = Infinity;\n  for (const b of boundaries) {\n    if (b < minPos || b > maxPos) continue;\n    const d = Math.abs(b - idealPos);\n    if (d < bestDist) {\n      bestDist = d;\n      best = b;\n    }\n  }\n  return best;\n}\n\nfunction splitTextByDurations(text, durations) {\n  const t = cleanText(text);\n  if (!durations.length) return [];\n  if (!t) return durations.map(() => \"\");\n  if (durations.length === 1) return [t];\n\n  const out = [];\n  const boundaries = findSentenceBoundaries(t);\n  const totalDur = durations.reduce((a, b) => a + b, 0);\n\n  let start = 0;\n  let accDur = 0;\n\n  for (let i = 0; i < durations.length - 1; i++) {\n    accDur += durations[i];\n\n    let ideal = Math.round((accDur / Math.max(1, totalDur)) * t.length);\n    ideal = Math.max(start + 1, Math.min(t.length - 1, ideal));\n\n    const minPos = start + 1;\n    const maxPos = t.length - 1;\n\n    let cut = nearestBoundary(boundaries, minPos, maxPos, ideal);\n\n    if (cut < 0) {\n      const wsLeft = lastWhitespaceBefore(t, ideal);\n      const wsRight = firstWhitespaceAfter(t, ideal);\n\n      const leftOk = wsLeft >= minPos && wsLeft <= maxPos;\n      const rightOk = wsRight >= minPos && wsRight <= maxPos;\n\n      if (leftOk && rightOk) {\n        cut = (Math.abs(wsLeft - ideal) <= Math.abs(wsRight - ideal)) ? wsLeft + 1 : wsRight + 1;\n      } else if (leftOk) {\n        cut = wsLeft + 1;\n      } else if (rightOk) {\n        cut = wsRight + 1;\n      } else {\n        cut = ideal;\n      }\n    }\n\n    cut = Math.max(minPos, Math.min(maxPos, cut));\n    out.push(cleanText(t.slice(start, cut)));\n    start = cut;\n  }\n\n  out.push(cleanText(t.slice(start)));\n  return out;\n}\n\nfunction splitPartStrict(part, minMs, maxMs) {\n  const dur = Math.max(0, Math.round(part?.meta?.durMs || 0));\n  if (dur <= 0) return [];\n\n  const durs = splitDurStrict(dur, minMs, maxMs);\n  const texts = splitTextByDurations(part?.text || \"\", durs);\n\n  return durs.map((d, i) => ({\n    text: cleanText(texts[i] || \"\"),\n    meta: { durMs: d }\n  }));\n}\n\nfunction mergeParts(a, b) {\n  const ta = cleanText(a?.text || \"\");\n  const tb = cleanText(b?.text || \"\");\n  return {\n    text: cleanText((ta && tb) ? (ta + \" \" + tb) : (ta || tb)),\n    meta: {\n      durMs: Math.max(0, Math.round((a?.meta?.durMs || 0) + (b?.meta?.durMs || 0)))\n    }\n  };\n}\n\nfunction rebalancePartsStrict(inputParts, minMs, maxMs) {\n  let parts = (Array.isArray(inputParts) ? inputParts : [])\n    .map(p => ({\n      text: cleanText(p?.text || \"\"),\n      meta: { durMs: Math.max(0, Math.round(p?.meta?.durMs || 0)) }\n    }))\n    .filter(p => p.meta.durMs > 0);\n\n  if (!parts.length) return [];\n\n  for (let iter = 0; iter < 300; iter++) {\n    let changed = false;\n\n    // 1) –í—Å–µ > max —Ä–µ–∂–µ–º —Å—Ä–∞–∑—É\n    let next = [];\n    for (const p of parts) {\n      if (p.meta.durMs > maxMs) {\n        next.push(...splitPartStrict(p, minMs, maxMs));\n        changed = true;\n      } else {\n        next.push(p);\n      }\n    }\n    parts = next;\n\n    // 2) –ò—â–µ–º –ø–µ—Ä–≤—ã–π –∫—É—Å–æ–∫ < min\n    const shortIdx = parts.findIndex(p => p.meta.durMs < minMs);\n    if (shortIdx === -1) {\n      if (!changed) break;\n      continue;\n    }\n\n    if (parts.length === 1) break; // total < min ‚Äî –Ω–µ–∏–∑–±–µ–∂–Ω–æ\n\n    const leftIdx = shortIdx - 1;\n    const rightIdx = shortIdx + 1;\n    const cur = parts[shortIdx];\n\n    let pickLeft = false;\n    if (leftIdx < 0) {\n      pickLeft = false;\n    } else if (rightIdx >= parts.length) {\n      pickLeft = true;\n    } else {\n      const leftDur = parts[leftIdx].meta.durMs + cur.meta.durMs;\n      const rightDur = parts[rightIdx].meta.durMs + cur.meta.durMs;\n\n      const leftOver = Math.max(0, leftDur - maxMs);\n      const rightOver = Math.max(0, rightDur - maxMs);\n\n      if (leftOver !== rightOver) {\n        pickLeft = leftOver < rightOver;\n      } else {\n        const target = (minMs + maxMs) / 2;\n        pickLeft = Math.abs(leftDur - target) <= Math.abs(rightDur - target);\n      }\n    }\n\n    if (pickLeft) {\n      parts[leftIdx] = mergeParts(parts[leftIdx], cur);\n      parts.splice(shortIdx, 1);\n    } else {\n      parts[rightIdx] = mergeParts(cur, parts[rightIdx]);\n      parts.splice(shortIdx, 1);\n    }\n\n    changed = true;\n    if (!changed) break;\n  }\n\n  // –§–∏–Ω–∞–ª—å–Ω—ã–π –∑–∞—â–∏—Ç–Ω—ã–π –ø—Ä–æ—Ö–æ–¥ –ø–æ max\n  const final = [];\n  for (const p of parts) {\n    if (p.meta.durMs <= maxMs) final.push(p);\n    else final.push(...splitPartStrict(p, minMs, maxMs));\n  }\n\n  return final;\n}\n\n// ===============================\n// üöÄ Core splitter (STRICT MAX + STRICT MIN/MAX PATCH)\n// ===============================\nfunction splitByMinMax(rawSegments, cfg) {\n  let { minMs, maxMs, softOverflowMs, totalDurMs } = cfg;\n\n  if (!Number.isFinite(minMs) || minMs <= 0) minMs = 2500;\n  if (!Number.isFinite(maxMs) || maxMs <= 0) maxMs = 4500;\n  if (minMs > maxMs) [minMs, maxMs] = [maxMs, minMs];\n\n  softOverflowMs = 0;\n  const hardMaxMs = maxMs;\n\n  // 1) –Ω–æ—Ä–º–∞–ª–∏–∑—É–µ–º —Å–µ–≥–º–µ–Ω—Ç—ã: text + startMs/endMs\n  const segs = (Array.isArray(rawSegments) ? rawSegments : [])\n    .map((seg, i) => {\n      const text = cleanText(seg?.[TEXT_KEY] ?? seg?.text ?? seg?.transcript ?? seg?.caption ?? \"\");\n      const se = normalizeStartEndMs({\n        start_ms: seg?.start_ms ?? pickFirst(seg, START_KEYS),\n        end_ms:   seg?.end_ms   ?? pickFirst(seg, END_KEYS),\n        start:    seg?.start    ?? pickFirst(seg, START_KEYS),\n        end:      seg?.end      ?? pickFirst(seg, END_KEYS),\n      });\n\n      return {\n        _origIndex: i,\n        text,\n        startMs: se.startMs,\n        endMs: se.endMs,\n      };\n    })\n    .filter(s => s.text);\n\n  // 2) –∑–∞–ø–æ–ª–Ω—è–µ–º –ø—Ä–æ–±–µ–ª—ã/—É–±–∏—Ä–∞–µ–º –ø–µ—Ä–µ–∫—Ä—ã—Ç–∏—è –ø–æ start/end\n  const filled = fillGapsInPlace(segs, totalDurMs);\n  totalDurMs = filled.totalDurMs;\n\n  // 3) –¥–ª—è —Å–±–æ—Ä–∫–∏ —á–∞—Å—Ç–µ–π –∏—Å–ø–æ–ª—å–∑—É–µ–º durMs = end-start (–∫–∞–∫ –≤ –æ—Ä–∏–≥–∏–Ω–∞–ª–µ)\n  const segments = segs.map(s => ({\n    text: s.text,\n    durMs: Math.max(0, s.endMs - s.startMs),\n  }));\n\n  // 4) Draft split: —Å–æ–±–ª—é–¥–∞–µ–º max, –¥–∞–ª—å—à–µ —Å—Ç—Ä–æ–≥–∏–π —Ä–µ–±–∞–ª–∞–Ω—Å\n  const draftParts = [];\n\n  function pushPart(txt, dur) {\n    const t = cleanText(txt);\n    if (!t) return;\n\n    const d = Math.max(0, Math.round(dur));\n    draftParts.push({\n      text: t,\n      meta: { durMs: d },\n    });\n  }\n\n  let bufText = \"\";\n  let bufDurMs = 0;\n\n  function cutBufferStrict() {\n    const t = bufText;\n    const totalChars = t.length;\n\n    if (!totalChars || bufDurMs <= 0) {\n      pushPart(t, bufDurMs);\n      bufText = \"\";\n      bufDurMs = 0;\n      return true;\n    }\n\n    const denom = Math.max(1, bufDurMs);\n\n    let maxChar = Math.floor(totalChars * (maxMs / denom));\n    maxChar = Math.max(1, Math.min(totalChars - 1, maxChar));\n\n    let minChar = Math.floor(totalChars * (minMs / denom));\n    minChar = Math.max(0, Math.min(maxChar, minChar));\n\n    const boundaries = findSentenceBoundaries(t);\n    let cutIdx = -1;\n\n    // 1) –≥—Ä–∞–Ω–∏—Ü–∞ –≤ [minChar..maxChar]\n    for (let i = boundaries.length - 1; i >= 0; i--) {\n      const b = boundaries[i];\n      if (b >= minChar && b <= maxChar) { cutIdx = b; break; }\n    }\n\n    // 2) –ø–æ–∑–¥–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞ <= maxChar\n    if (cutIdx < 0) {\n      for (let i = boundaries.length - 1; i >= 0; i--) {\n        const b = boundaries[i];\n        if (b <= maxChar) { cutIdx = b; break; }\n      }\n    }\n\n    // 3) –ø—Ä–æ–±–µ–ª <= maxChar\n    if (cutIdx < 0) {\n      const ws = lastWhitespaceBefore(t, maxChar);\n      if (ws > 0) cutIdx = ws + 1;\n    }\n\n    // 4) –∏–Ω–∞—á–µ ‚Äî —Ä–æ–≤–Ω–æ maxChar\n    if (cutIdx < 1 || cutIdx >= totalChars) cutIdx = maxChar;\n\n    const leftRaw = t.slice(0, cutIdx);\n    const rightRaw = t.slice(cutIdx);\n\n    const leftText = cleanText(leftRaw);\n    const rightText = cleanText(rightRaw);\n\n    const leftRatio = cutIdx / Math.max(1, totalChars);\n    let leftDur = Math.floor(bufDurMs * leftRatio);\n    if (leftDur > maxMs) leftDur = maxMs;\n    if (leftDur < 0) leftDur = 0;\n\n    const rightDur = Math.max(0, bufDurMs - leftDur);\n\n    pushPart(leftText, leftDur);\n    bufText = rightText;\n    bufDurMs = rightDur;\n\n    return true;\n  }\n\n  for (const seg of segments) {\n    bufText = bufText ? (bufText + \" \" + seg.text) : seg.text;\n    bufDurMs += seg.durMs;\n\n    while (bufText && bufDurMs > hardMaxMs) {\n      cutBufferStrict();\n      if (bufDurMs < minMs) break;\n    }\n  }\n\n  if (bufText) {\n    while (bufText && bufDurMs > hardMaxMs) {\n      cutBufferStrict();\n      if (bufDurMs < minMs) break;\n    }\n    if (bufText) pushPart(bufText, bufDurMs);\n  }\n\n  // 5) –ü–∞—Ç—á: —Ä–µ–±–∞–ª–∞–Ω—Å–∏–º, —á—Ç–æ–±—ã durMs –±—ã–ª–∏ –≤ [min..max], –∫–æ–≥–¥–∞ —ç—Ç–æ –≤–æ–∑–º–æ–∂–Ω–æ\n  const strictParts = rebalancePartsStrict(draftParts, minMs, maxMs);\n\n  // 6) –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –í–°–ï –ø–æ–ª—è –∫–∞–∫ –≤ –æ—Ä–∏–≥–∏–Ω–∞–ª–µ\n  const parts = strictParts.map((p, i) => {\n    const t = cleanText(p.text);\n    return {\n      partIndex: i,\n      text: t,\n      meta: {\n        durMs: Math.max(0, Math.round(p.meta.durMs || 0)),\n        charCount: t.length,\n      },\n    };\n  });\n\n  return {\n    parts,\n    minMs,\n    maxMs,\n    softOverflowMs,\n    hardMaxMs,\n    totalDurMs,\n  };\n}\n\n// ===============================\n// ‚úÖ Run\n// ===============================\nconst result = splitByMinMax(RAW_SEGMENTS, {\n  minMs: EACH_IMAGE_MIN_SCREEN_TIME_MS,\n  maxMs: EACH_IMAGE_MAX_SCREEN_TIME_MS,\n  softOverflowMs: SOFT_OVERFLOW_MS,\n  totalDurMs: TOTAL_DUR_MS,\n});\n\nreturn [\n  {\n    json: {\n      parts: result.parts,\n      totalDurMs: result.totalDurMs,\n      eachImageMinScreenTimeMs: result.minMs,\n      eachImageMaxScreenTimeMs: result.maxMs,\n      hardMaxMs: result.hardMaxMs,\n    }\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1520,
        240
      ],
      "id": "594e8d73-a46f-4f4f-a959-608c4429c75c",
      "name": "Define Visuals Duration(normalized) and Text Part"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "974699bd-a2c3-457a-88c1-a1a4619935ec",
              "name": "",
              "value": "={{ $json.parts.map(item => item.meta.durMs).sort() }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1744,
        64
      ],
      "id": "3fbc42b4-6772-43b5-a5e1-7e755c6a2c71",
      "name": "Edit Fields"
    }
  ],
  "connections": {
    "Start": {
      "main": [
        [
          {
            "node": "get text gen service and eachVisualScreenTime",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch Text Gen Service": {
      "main": [
        [
          {
            "node": "get ready clips prompts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Out": {
      "main": [
        [
          {
            "node": "Filter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter": {
      "main": [
        [
          {
            "node": "generate clips prompts im gemini - paralleling",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Audio Ready": {
      "main": [
        [
          {
            "node": "Limit1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Wait",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Limit1": {
      "main": [
        [
          {
            "node": "set clips prompts ready",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait": {
      "main": [
        [
          {
            "node": "check if clips prompts ready",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "check if clips prompts ready": {
      "main": [
        [
          {
            "node": "If Audio Ready",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "get text gen service and eachVisualScreenTime": {
      "main": [
        [
          {
            "node": "get start/end ms of each scentance from transcript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "get start/end ms of each scentance from transcript": {
      "main": [
        [
          {
            "node": "Switch Text Gen Service",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "get ready clips prompts": {
      "main": [
        [
          {
            "node": "Define Visuals Duration(normalized) and Text Part",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Define Visuals Duration(normalized) and Text Part": {
      "main": [
        [
          {
            "node": "check if clips prompts ready",
            "type": "main",
            "index": 0
          },
          {
            "node": "Split Out",
            "type": "main",
            "index": 0
          },
          {
            "node": "Edit Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": null,
  "pinData": {
    "Start": [
      {
        "json": {
          "channelsFolderPath": "C:/Users/V/Desktop/Channels",
          "channelName": "WgladWPrzeszlosc",
          "videoFolderName": "2026-02-08_VySCN"
        },
        "pairedItem": {
          "item": 0
        }
      }
    ]
  },
  "versionId": "e818fda5-da37-4e9d-9b5c-fdccb953da82",
  "activeVersionId": "e818fda5-da37-4e9d-9b5c-fdccb953da82",
  "versionCounter": 455,
  "triggerCount": 0,
  "tags": [],
  "shared": [
    {
      "updatedAt": "2026-02-05T01:25:42.642Z",
      "createdAt": "2026-02-05T01:25:42.642Z",
      "role": "workflow:owner",
      "workflowId": "C4PCujSuMWddLkKC",
      "projectId": "jyxvHYm2zz0wpNIZ",
      "project": {
        "updatedAt": "2026-02-03T20:00:07.843Z",
        "createdAt": "2026-02-03T19:58:35.642Z",
        "id": "jyxvHYm2zz0wpNIZ",
        "name": "Vladislav Kostromin <bad4rr@gmail.com>",
        "type": "personal",
        "icon": null,
        "description": null,
        "creatorId": "791bcae9-1f6e-48f2-9f28-d86a2c32ea27"
      }
    }
  ]
}