{
  "updatedAt": "2026-02-10T01:19:20.357Z",
  "createdAt": "2026-02-04T19:31:36.029Z",
  "id": "du4UzkaJt01yiEEG",
  "name": "generate voiceover",
  "description": null,
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "inputSource": "jsonExample",
        "jsonExample": "{\n  \"channelsFolderPath\": \"\",\n  \"channelName\": \"\",\n  \"videoFolderName\": \"\"\n}"
      },
      "id": "c055762a-8fe7-4141-a639-df2372f30060",
      "typeVersion": 1.1,
      "name": "Start",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "position": [
        272,
        352
      ]
    },
    {
      "parameters": {
        "jsCode": "// --- ВХОДНЫЕ ПЕРЕМЕННЫЕ (как у тебя) ---\nconst textPartsLength = Number($('get audio gen service and textPartsLength').first().json.textPartsLength); // максимум длины части\nconst text = String($('get whole text from TXT file').first().json.text ?? \"\");        // исходный текст\n\n// --- ЛОГИКА ---\nconst partsArr = splitBalancedTTS(text, textPartsLength);\n\n// --- ВЫХОД ---\nreturn partsArr.map((partText, partIndex) => ({\n  json: {\n    partIndex,\n    text: partText,\n  },\n}));\n\n// ================== FUNCTIONS ==================\n\nfunction splitBalancedTTS(source, limit) {\n  if (!limit || limit <= 0) {\n    return source && source.trim() ? [source] : [];\n  }\n\n  const sents = splitIntoSentencesWithParas(source);\n\n  // 1) Нормализация сверхдлинных предложений\n  const normalized = [];\n  for (const s of sents) {\n    if (s === \"\\n\\n\") {\n      normalized.push(s);\n      continue;\n    }\n    if (s.length <= limit) {\n      normalized.push(s);\n      continue;\n    }\n    let rest = s;\n    while (rest.length > limit) {\n      const bp = findBreak(rest, limit);\n      const chunk = rest.slice(0, bp).trim();\n      if (chunk) normalized.push(chunk);\n      rest = rest.slice(bp).trim();\n    }\n    if (rest.trim()) normalized.push(rest.trim());\n  }\n\n  const n = normalized.length;\n  const pref = new Array(n + 1).fill(0);\n  for (let i = 0; i < n; i++) {\n    pref[i + 1] = pref[i] + normalized[i].length;\n  }\n\n  const chunkCost = (i, j) => {\n    const length = pref[j] - pref[i];\n    if (length > limit) return Infinity;\n    const slack = limit - length;\n    return slack * slack;\n  };\n\n  const best = new Array(n + 1).fill(Infinity);\n  const nextBreak = new Array(n + 1).fill(-1);\n  best[n] = 0;\n\n  for (let i = n - 1; i >= 0; i--) {\n    if (normalized[i] === \"\\n\\n\") {\n      best[i] = best[i + 1];\n      nextBreak[i] = i + 1;\n      continue;\n    }\n    let j = i + 1;\n    while (j <= n && (pref[j] - pref[i]) <= limit) {\n      const cost = chunkCost(i, j) + best[j];\n      if (cost < best[i]) {\n        best[i] = cost;\n        nextBreak[i] = j;\n      }\n      j++;\n    }\n  }\n\n  const chunks = [];\n  let i = 0;\n  while (i < n) {\n    let j = nextBreak[i];\n    if (j === -1 || j <= i) j = Math.min(n, i + 1);\n    const text = normalized.slice(i, j).join(\"\").trim();\n    if (text) chunks.push(text);\n    i = j;\n  }\n  return chunks;\n}\n\nfunction splitIntoSentencesWithParas(source) {\n  const result = [];\n  const paras = source.split(/\\n\\s*\\n/);\n  for (let pIdx = 0; pIdx < paras.length; pIdx++) {\n    const p = (paras[pIdx] || \"\").trim();\n    if (!p) continue;\n\n    let i = 0;\n    const rx = /([.!?…]+[)\"»\\]]*)(\\s+|$)/g;\n    const masked = maskTags(p);\n\n    let m;\n    while ((m = rx.exec(masked)) !== null) {\n      const end = m.index + m[0].length;\n      const sent = p.slice(i, end);\n      if (sent.trim()) result.push(sent);\n      i = end;\n    }\n    if (i < p.length) {\n      const tail = p.slice(i);\n      if (tail.trim()) result.push(tail);\n    }\n    if (pIdx < paras.length - 1) result.push(\"\\n\\n\");\n  }\n\n  // dedupe repeated paragraph separators\n  const compact = [];\n  for (const cur of result) {\n    if (cur === \"\\n\\n\" && compact.length && compact[compact.length - 1] === \"\\n\\n\") {\n      continue;\n    }\n    compact.push(cur);\n  }\n  return compact;\n}\n\nfunction findBreak(remaining, limit) {\n  const windowText = remaining.slice(0, limit);\n  const masked = maskTags(windowText);\n  const spans = getTagSpans(remaining);\n\n  let best = -1;\n  const rx = /([.!?…]+[)\"»\\]]?\\s)/g;\n  let m;\n  while ((m = rx.exec(masked)) !== null) {\n    best = m.index + m[0].length;\n  }\n\n  if (best >= Math.floor(limit * 0.6)) {\n    let idx = adjustBreakIndex(best, spans);\n    if (idx <= 0) idx = Math.max(1, best);\n    return safeBreakIndex(remaining, idx);\n  }\n\n  const lastSpace = Math.max(\n    masked.lastIndexOf(\" \"),\n    masked.lastIndexOf(\"\\n\"),\n    masked.lastIndexOf(\"\\t\")\n  );\n  if (lastSpace > 0) {\n    let idx = adjustBreakIndex(lastSpace + 1, spans);\n    if (idx <= 0) idx = Math.max(1, lastSpace + 1);\n    return safeBreakIndex(remaining, idx);\n  }\n\n  let idx = adjustBreakIndex(limit, spans);\n  if (idx <= 0) {\n    if (spans.length && spans[0][0] === 0) idx = spans[0][1];\n    if (idx <= 0) idx = 1;\n  }\n  return safeBreakIndex(remaining, idx);\n}\n\nfunction getTagSpans(text) {\n  const spans = [];\n  if (!text.includes(\"[\")) return spans;\n  let i = 0;\n  while (i < text.length) {\n    const start = text.indexOf(\"[\", i);\n    if (start === -1) break;\n    const end = text.indexOf(\"]\", start + 1);\n    if (end === -1) {\n      spans.push([start, text.length]);\n      break;\n    }\n    spans.push([start, end + 1]); // end exclusive\n    i = end + 1;\n  }\n  return spans;\n}\n\nfunction maskTags(text) {\n  if (!text.includes(\"[\")) return text;\n  const spans = getTagSpans(text);\n  if (!spans.length) return text;\n  const chars = text.split(\"\");\n  for (const [start, end] of spans) {\n    for (let i = start; i < end; i++) chars[i] = \"a\";\n  }\n  return chars.join(\"\");\n}\n\nfunction adjustBreakIndex(idx, spans) {\n  for (const [start, end] of spans) {\n    if (start < idx && idx < end) {\n      if (start > 0) return start;\n      return end;\n    }\n  }\n  return idx;\n}\n\nfunction safeBreakIndex(s, idx) {\n  if (idx > 0 && idx < s.length) {\n    const prev = s.charCodeAt(idx - 1);\n    const curr = s.charCodeAt(idx);\n    if (0xD800 <= prev && prev <= 0xDBFF && 0xDC00 <= curr && curr <= 0xDFFF) {\n      idx -= 1;\n    }\n  }\n  if (idx < 0) return 0;\n  if (idx > s.length) return s.length;\n  return idx;\n}\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1392,
        240
      ],
      "id": "37507078-6031-42ce-b17d-67d73c08fb03",
      "name": "split text to parts"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "QGwzjOX1i2qj5DPR",
          "mode": "list",
          "cachedResultUrl": "/workflow/QGwzjOX1i2qj5DPR",
          "cachedResultName": "generate elevenlabs audio - paralleling"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "channelsFolderPath": "={{ $('Start').first().json.channelsFolderPath }}",
            "channelName": "={{ $('Start').first().json.channelName }}",
            "videoFolderName": "={{ $('Start').first().json.videoFolderName }}",
            "textPartIndex": "={{ $json.partIndex }}",
            "textPart": "={{ $json.text }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "channelsFolderPath",
              "displayName": "channelsFolderPath",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "channelName",
              "displayName": "channelName",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "videoFolderName",
              "displayName": "videoFolderName",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "textPart",
              "displayName": "textPart",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "textPartIndex",
              "displayName": "textPartIndex",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "mode": "each",
        "options": {
          "waitForSubWorkflow": false
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        1904,
        240
      ],
      "id": "1047bd1d-a118-4de1-8963-232ea80232b1",
      "name": "generate elevenlabs audio - paralleling"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "N2bXusYBgofvRBlH",
          "mode": "list",
          "cachedResultUrl": "/workflow/N2bXusYBgofvRBlH",
          "cachedResultName": "check files quantity in directory"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "expectedFilesCount": "={{ $('split text to parts').last().json.partIndex+1 }}",
            "directoryPath": "={{ $('Start').first().json.channelsFolderPath }}/{{ $('Start').first().json.channelName }}/VIDEOS/{{ $('Start').first().json.videoFolderName }}/VOICE",
            "fileExtentionToSearch": ".mp3"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "directoryPath",
              "displayName": "directoryPath",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "fileExtentionToSearch",
              "displayName": "fileExtentionToSearch",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "fileNameToSearch",
              "displayName": "fileNameToSearch",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "expectedFilesCount",
              "displayName": "expectedFilesCount",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        1696,
        384
      ],
      "id": "7d61ce44-e28b-4e4c-8289-6e993e7d147c",
      "name": "check if files ready"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "e75bcbea-1374-432d-a6cd-6b9f2cc42c78",
              "leftValue": "={{ $('check if files ready').last().json.filesReady }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        1904,
        384
      ],
      "id": "492c64f4-f88a-4113-9f7b-a9a9f2f84323",
      "name": "If Audio Ready"
    },
    {
      "parameters": {
        "amount": 15
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        2000,
        480
      ],
      "id": "4ffd3677-eee5-4686-964f-5f3a873e784b",
      "name": "Wait",
      "webhookId": "acf3fd65-1471-4d76-af5f-1c5dd091db93"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.limit",
      "typeVersion": 1,
      "position": [
        2160,
        384
      ],
      "id": "9357c574-c13a-4ab2-86a6-ff07a9435eca",
      "name": "Limit1"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "qwG1pltFOQqqJLyh",
          "mode": "list",
          "cachedResultUrl": "/workflow/qwG1pltFOQqqJLyh",
          "cachedResultName": "JSON File Works"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "filePath": "={{ $('Start').first().json.channelsFolderPath }}/{{ $('Start').first().json.channelName }}/VIDEOS/{{ $('Start').first().json.videoFolderName }}/videoStatus.json",
            "fileAction": "write",
            "keysToReturn": "={{ [] }}",
            "keysToWrite": "={{ {\n\"voiceoverReady\":true\n} }}",
            "keysToDelete": "={{ [] }}"
          },
          "matchingColumns": [
            "channelsFolderPath_firstItem",
            "channelName_firstItem"
          ],
          "schema": [
            {
              "id": "filePath",
              "displayName": "filePath",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "fileAction",
              "displayName": "fileAction",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "keysToReturn",
              "displayName": "keysToReturn",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "array",
              "removed": false
            },
            {
              "id": "keysToWrite",
              "displayName": "keysToWrite",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "object",
              "removed": false
            },
            {
              "id": "keysToDelete",
              "displayName": "keysToDelete",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "array",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        2352,
        384
      ],
      "name": "set voiceover ready",
      "id": "a742cdce-4320-4097-aed2-1a86efe03d5b"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "N2bXusYBgofvRBlH",
          "mode": "list",
          "cachedResultUrl": "/workflow/N2bXusYBgofvRBlH",
          "cachedResultName": "check files quantity in directory"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "directoryPath": "={{ $('Start').first().json.channelsFolderPath }}/{{ $('Start').first().json.channelName }}/VIDEOS/{{ $('Start').first().json.videoFolderName }}/VOICE",
            "fileExtentionToSearch": ".mp3",
            "expectedFilesCount": -1
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "directoryPath",
              "displayName": "directoryPath",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "fileExtentionToSearch",
              "displayName": "fileExtentionToSearch",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "fileNameToSearch",
              "displayName": "fileNameToSearch",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "expectedFilesCount",
              "displayName": "expectedFilesCount",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        1184,
        240
      ],
      "id": "d524fea0-3687-492f-a5ab-d1771db44a92",
      "name": "get existing audio files"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "01bf6e6d-2a96-46b9-9c83-df20b2a5c17e",
              "leftValue": "={{(()=>{\nlet existingPartsIndexes = []\n\nif ($('get existing audio files').item.json.existingFilesNames.length > 0){\n  existingPartsIndexes = $('get existing audio files').first().json.existingFilesNames.map(name=>name.slice(-9,-4).toInt())\n}\n\nconst partIndex = $json.partIndex\n\nreturn !existingPartsIndexes.includes(partIndex)\n})()}}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.filter",
      "typeVersion": 2.3,
      "position": [
        1696,
        240
      ],
      "id": "190182c1-89b1-470f-ade2-1a6bd75f0f34",
      "name": "Filter Ready Parts"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.audioGenService == \"elevenlabs\" }}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "id": "dc3b77df-1288-4bc2-9528-6f340e6a85a1"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "elevenlabs"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "0c18c801-d575-40c2-9226-d6e46fb02f14",
                    "leftValue": "={{ $json.audioGenService == \"runpod\" }}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "runpod"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.4,
      "position": [
        688,
        352
      ],
      "id": "b499b5ec-fe90-42a4-b766-b24807ce26b2",
      "name": "Switch by A Gudio gen Service"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "jN0HNmDZY1IKD2vM-oIO3",
          "mode": "list",
          "cachedResultUrl": "/workflow/jN0HNmDZY1IKD2vM-oIO3",
          "cachedResultName": "Text file works"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "filePath": "={{ $('Start').first().json.channelsFolderPath }}/{{ $('Start').first().json.channelName }}/VIDEOS/{{ $('Start').first().json.videoFolderName }}/TEXTS/{{ $('Start').first().json.videoFolderName }}.txt",
            "fileAction": "=read"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "filePath",
              "displayName": "filePath",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "fileAction",
              "displayName": "fileAction",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "text",
              "displayName": "text",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        960,
        240
      ],
      "name": "get whole text from TXT file",
      "id": "39732aa6-3eca-4630-a112-a585ef591981"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "qwG1pltFOQqqJLyh",
          "mode": "list",
          "cachedResultUrl": "/workflow/qwG1pltFOQqqJLyh",
          "cachedResultName": "JSON File Works"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "filePath": "={{ $('Start').first().json.channelsFolderPath }}/{{ $('Start').first().json.channelName }}/settings.json",
            "fileAction": "read",
            "keysToReturn": "={{ [\"audioGenService\", \"textPartsLength\"] }}",
            "keysToWrite": "={{ {} }}",
            "keysToDelete": "={{ [] }}"
          },
          "matchingColumns": [
            "channelsFolderPath_firstItem",
            "channelName_firstItem"
          ],
          "schema": [
            {
              "id": "filePath",
              "displayName": "filePath",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "fileAction",
              "displayName": "fileAction",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "keysToReturn",
              "displayName": "keysToReturn",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "array",
              "removed": false
            },
            {
              "id": "keysToWrite",
              "displayName": "keysToWrite",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "object",
              "removed": false
            },
            {
              "id": "keysToDelete",
              "displayName": "keysToDelete",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "array",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        480,
        352
      ],
      "name": "get audio gen service and textPartsLength",
      "id": "1a35bf38-290f-4f69-baaa-ac5ab1b12123"
    }
  ],
  "connections": {
    "Start": {
      "main": [
        [
          {
            "node": "get audio gen service and textPartsLength",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "split text to parts": {
      "main": [
        [
          {
            "node": "Filter Ready Parts",
            "type": "main",
            "index": 0
          },
          {
            "node": "check if files ready",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "generate elevenlabs audio - paralleling": {
      "main": [
        []
      ]
    },
    "check if files ready": {
      "main": [
        [
          {
            "node": "If Audio Ready",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Audio Ready": {
      "main": [
        [
          {
            "node": "Limit1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Wait",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait": {
      "main": [
        [
          {
            "node": "check if files ready",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Limit1": {
      "main": [
        [
          {
            "node": "set voiceover ready",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "get existing audio files": {
      "main": [
        [
          {
            "node": "split text to parts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter Ready Parts": {
      "main": [
        [
          {
            "node": "generate elevenlabs audio - paralleling",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch by A Gudio gen Service": {
      "main": [
        [
          {
            "node": "get whole text from TXT file",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "get whole text from TXT file": {
      "main": [
        [
          {
            "node": "get existing audio files",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "get audio gen service and textPartsLength": {
      "main": [
        [
          {
            "node": "Switch by A Gudio gen Service",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": null,
  "pinData": {
    "Start": [
      {
        "json": {
          "channelsFolderPath": "C:/Users/V/Desktop/Channels",
          "channelName": "WgladWPrzeszlosc",
          "videoFolderName": "2026-02-08_VySCN"
        },
        "pairedItem": {
          "item": 0
        }
      }
    ]
  },
  "versionId": "af15d50a-3c2a-49b1-9747-7c128a62e60d",
  "activeVersionId": "af15d50a-3c2a-49b1-9747-7c128a62e60d",
  "versionCounter": 295,
  "triggerCount": 0,
  "tags": [],
  "shared": [
    {
      "updatedAt": "2026-02-04T19:31:36.032Z",
      "createdAt": "2026-02-04T19:31:36.032Z",
      "role": "workflow:owner",
      "workflowId": "du4UzkaJt01yiEEG",
      "projectId": "jyxvHYm2zz0wpNIZ",
      "project": {
        "updatedAt": "2026-02-03T20:00:07.843Z",
        "createdAt": "2026-02-03T19:58:35.642Z",
        "id": "jyxvHYm2zz0wpNIZ",
        "name": "Vladislav Kostromin <bad4rr@gmail.com>",
        "type": "personal",
        "icon": null,
        "description": null,
        "creatorId": "791bcae9-1f6e-48f2-9f28-d86a2c32ea27"
      }
    }
  ]
}